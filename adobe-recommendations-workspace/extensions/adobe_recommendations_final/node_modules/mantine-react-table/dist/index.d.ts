/// <reference types="react" />
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as react from 'react';
import { HTMLProps, MutableRefObject, Dispatch, SetStateAction, ReactNode, RefObject, DragEventHandler, MouseEvent } from 'react';
import { PaginationProps, ActionIconProps, UnstyledButtonProps, MultiSelectProps, TextInputProps, AutocompleteProps, RangeSliderProps, SelectProps, BoxProps, ModalProps, CheckboxProps, HighlightProps, LoadingOverlayProps, ProgressProps, PaperProps, RadioProps, SwitchProps, SkeletonProps, TableProps, BadgeProps, AlertProps, MantineTheme } from '@mantine/core';
import { DateInputProps } from '@mantine/dates';
import * as _tanstack_react_table from '@tanstack/react-table';
import { Row, ColumnFiltersState, ColumnOrderState, ColumnPinningState, ColumnSizingInfoState, ColumnSizingState, ExpandedState, GroupingState, PaginationState, RowSelectionState, SortingState, Updater, VisibilityState, AccessorFn, DeepKeys, DeepValue, Table, TableState, ColumnDef, Column, Header, HeaderGroup, Cell, AggregationFn, SortingFn, FilterFn, TableOptions, OnChangeFn, Renderable } from '@tanstack/react-table';
import { VirtualItem, VirtualizerOptions, Virtualizer, Range } from '@tanstack/react-virtual';
import * as _tanstack_match_sorter_utils from '@tanstack/match-sorter-utils';
import { RankingInfo } from '@tanstack/match-sorter-utils';
import * as _tabler_icons_react from '@tabler/icons-react';

declare const MRT_AggregationFns: {
    sum: _tanstack_react_table.AggregationFn<any>;
    min: _tanstack_react_table.AggregationFn<any>;
    max: _tanstack_react_table.AggregationFn<any>;
    extent: _tanstack_react_table.AggregationFn<any>;
    mean: _tanstack_react_table.AggregationFn<any>;
    median: _tanstack_react_table.AggregationFn<any>;
    unique: _tanstack_react_table.AggregationFn<any>;
    uniqueCount: _tanstack_react_table.AggregationFn<any>;
    count: _tanstack_react_table.AggregationFn<any>;
};

declare const MRT_FilterFns: {
    between: {
        <TData extends MRT_RowData>(row: Row<TData>, id: string, filterValues: [string | number, string | number]): boolean;
        autoRemove(val: any): boolean;
    };
    betweenInclusive: {
        <TData_1 extends MRT_RowData>(row: Row<TData_1>, id: string, filterValues: [string | number, string | number]): boolean;
        autoRemove(val: any): boolean;
    };
    contains: {
        <TData_2 extends MRT_RowData>(row: Row<TData_2>, id: string, filterValue: string | number): boolean;
        autoRemove(val: any): boolean;
    };
    empty: {
        <TData_3 extends MRT_RowData>(row: Row<TData_3>, id: string, _filterValue: string | number): boolean;
        autoRemove(val: any): boolean;
    };
    endsWith: {
        <TData_4 extends MRT_RowData>(row: Row<TData_4>, id: string, filterValue: string | number): boolean;
        autoRemove(val: any): boolean;
    };
    equals: {
        <TData_5 extends MRT_RowData>(row: Row<TData_5>, id: string, filterValue: string | number | null): boolean;
        autoRemove(val: any): boolean;
    };
    fuzzy: {
        <TData_6 extends MRT_RowData>(row: Row<TData_6>, columnId: string, filterValue: string | number, addMeta: (item: RankingInfo) => void): boolean;
        autoRemove(val: any): boolean;
    };
    greaterThan: {
        <TData_7 extends MRT_RowData>(row: Row<TData_7>, id: string, filterValue: string | number | null): boolean;
        autoRemove(val: any): boolean;
    };
    greaterThanOrEqualTo: {
        <TData_8 extends MRT_RowData>(row: Row<TData_8>, id: string, filterValue: string | number): boolean;
        autoRemove(val: any): boolean;
    };
    lessThan: {
        <TData_9 extends MRT_RowData>(row: Row<TData_9>, id: string, filterValue: string | number | null): boolean;
        autoRemove(val: any): boolean;
    };
    lessThanOrEqualTo: {
        <TData_10 extends MRT_RowData>(row: Row<TData_10>, id: string, filterValue: string | number): boolean;
        autoRemove(val: any): boolean;
    };
    notEmpty: {
        <TData_11 extends MRT_RowData>(row: Row<TData_11>, id: string, _filterValue: string | number): boolean;
        autoRemove(val: any): boolean;
    };
    notEquals: {
        <TData_12 extends MRT_RowData>(row: Row<TData_12>, id: string, filterValue: string | number): boolean;
        autoRemove(val: any): boolean;
    };
    startsWith: {
        <TData_13 extends MRT_RowData>(row: Row<TData_13>, id: string, filterValue: string | number): boolean;
        autoRemove(val: any): boolean;
    };
    includesString: _tanstack_react_table.FilterFn<any>;
    includesStringSensitive: _tanstack_react_table.FilterFn<any>;
    equalsString: _tanstack_react_table.FilterFn<any>;
    arrIncludes: _tanstack_react_table.FilterFn<any>;
    arrIncludesAll: _tanstack_react_table.FilterFn<any>;
    arrIncludesSome: _tanstack_react_table.FilterFn<any>;
    weakEquals: _tanstack_react_table.FilterFn<any>;
    inNumberRange: _tanstack_react_table.FilterFn<any>;
};
declare function localizedFilterOption(localization: MRT_Localization, option: MRT_FilterOption): string;

declare const MRT_SortingFns: {
    fuzzy: <TData extends MRT_RowData>(rowA: Row<TData>, rowB: Row<TData>, columnId: string) => number;
    alphanumeric: _tanstack_react_table.SortingFn<any>;
    alphanumericCaseSensitive: _tanstack_react_table.SortingFn<any>;
    text: _tanstack_react_table.SortingFn<any>;
    textCaseSensitive: _tanstack_react_table.SortingFn<any>;
    datetime: _tanstack_react_table.SortingFn<any>;
    basic: _tanstack_react_table.SortingFn<any>;
};
declare const rankGlobalFuzzy: <TData extends MRT_RowData>(rowA: MRT_Row<TData>, rowB: MRT_Row<TData>) => number;

declare const MRT_Default_Icons: {
    readonly IconArrowAutofitContent: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconArrowsSort: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconBaselineDensityLarge: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconBaselineDensityMedium: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconBaselineDensitySmall: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconBoxMultiple: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconChevronDown: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconChevronLeft: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconChevronLeftPipe: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconChevronRight: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconChevronRightPipe: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconChevronsDown: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconCircleX: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconClearAll: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconColumns: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconDeviceFloppy: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconDots: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconDotsVertical: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconEdit: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconEyeOff: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconFilter: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconFilterCog: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconFilterOff: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconGripHorizontal: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconMaximize: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconMinimize: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconPinned: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconPinnedOff: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconSearch: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconSearchOff: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconSortAscending: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconSortDescending: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
    readonly IconX: (props: _tabler_icons_react.TablerIconsProps) => JSX.Element;
};
type MRT_Icons = Record<keyof typeof MRT_Default_Icons, any>;

type LiteralUnion<T extends U, U = string> = T | (U & Record<never, never>);
type Prettify<T> = {
    [K in keyof T]: T[K];
} & unknown;
type Xor<A, B> = Prettify<A & {
    [k in keyof B]?: never;
}> | Prettify<B & {
    [k in keyof A]?: never;
}>;
type HTMLPropsRef<T extends HTMLElement> = Omit<HTMLProps<T>, 'color' | 'size' | 'type' | 'ref' | 'data' | 'label' | 'style'> & {
    ref?: MutableRefObject<T | null> | null;
};
type MantineShade = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
type ColumnAlignment = {
    align?: 'left' | 'center' | 'right';
};
type MRT_PaginationProps = Partial<PaginationProps> & {
    rowsPerPageOptions?: string[];
    showRowsPerPage?: boolean;
};
type MRT_DensityState = 'xs' | 'md' | 'xl';
type MRT_ColumnFilterFnsState = Record<string, MRT_FilterOption>;
type MRT_RowData = Record<string, any>;
type MRT_CellValue = unknown;
type MRT_ColumnFiltersState = ColumnFiltersState;
type MRT_ColumnOrderState = ColumnOrderState;
type MRT_ColumnPinningState = ColumnPinningState;
type MRT_ColumnSizingInfoState = ColumnSizingInfoState;
type MRT_ColumnSizingState = ColumnSizingState;
type MRT_ExpandedState = ExpandedState;
type MRT_GroupingState = GroupingState;
type MRT_PaginationState = PaginationState;
type MRT_RowSelectionState = RowSelectionState;
type MRT_SortingState = SortingState;
type MRT_Updater<T> = Updater<T>;
type MRT_VirtualItem = VirtualItem;
type MRT_VisibilityState = VisibilityState;
type MRT_VirtualizerOptions<TScrollElement extends Element | Window = Element | Window, TItemElement extends Element = Element> = VirtualizerOptions<TScrollElement, TItemElement>;
type MRT_ColumnVirtualizer<TScrollElement extends Element | Window = HTMLDivElement, TItemElement extends Element = HTMLTableCellElement> = Virtualizer<TScrollElement, TItemElement> & {
    virtualColumns: MRT_VirtualItem[];
    virtualPaddingLeft?: number;
    virtualPaddingRight?: number;
};
type MRT_RowVirtualizer<TScrollElement extends Element | Window = HTMLDivElement, TItemElement extends Element = HTMLTableRowElement> = Virtualizer<TScrollElement, TItemElement> & {
    virtualRows: MRT_VirtualItem[];
};
type MRT_ColumnHelper<TData extends MRT_RowData> = {
    accessor: <TAccessor extends AccessorFn<TData> | DeepKeys<TData>, TValue extends TAccessor extends AccessorFn<TData, infer TReturn> ? TReturn : TAccessor extends DeepKeys<TData> ? DeepValue<TData, TAccessor> : never>(accessor: TAccessor, column: MRT_DisplayColumnDef<TData, TValue>) => MRT_ColumnDef<TData, TValue>;
    display: (column: MRT_DisplayColumnDef<TData>) => MRT_ColumnDef<TData>;
    group: (column: MRT_GroupColumnDef<TData>) => MRT_ColumnDef<TData>;
};
interface MRT_Localization {
    actions: string;
    and: string;
    cancel: string;
    changeFilterMode: string;
    changeSearchMode: string;
    clearFilter: string;
    clearSearch: string;
    clearSort: string;
    clickToCopy: string;
    collapse: string;
    collapseAll: string;
    columnActions: string;
    copiedToClipboard: string;
    create?: string;
    dropToGroupBy: string;
    edit: string;
    expand: string;
    expandAll: string;
    filterArrIncludes: string;
    filterArrIncludesAll: string;
    filterArrIncludesSome: string;
    filterBetween: string;
    filterBetweenInclusive: string;
    filterByColumn: string;
    filterContains: string;
    filterEmpty: string;
    filterEndsWith: string;
    filterEquals: string;
    filterEqualsString: string;
    filterFuzzy: string;
    filterGreaterThan: string;
    filterGreaterThanOrEqualTo: string;
    filterIncludesString: string;
    filterIncludesStringSensitive: string;
    filteringByColumn: string;
    filterInNumberRange: string;
    filterLessThan: string;
    filterLessThanOrEqualTo: string;
    filterMode: string;
    filterNotEmpty: string;
    filterNotEquals: string;
    filterStartsWith: string;
    filterWeakEquals: string;
    goToFirstPage: string;
    goToLastPage: string;
    goToNextPage: string;
    goToPreviousPage: string;
    grab: string;
    groupByColumn: string;
    groupedBy: string;
    hideAll: string;
    hideColumn: string;
    max: string;
    min: string;
    move: string;
    noRecordsToDisplay: string;
    noResultsFound: string;
    of: string;
    or: string;
    pin: string;
    pinToLeft: string;
    pinToRight: string;
    resetColumnSize: string;
    resetOrder: string;
    rowActions: string;
    rowNumber: string;
    rowNumbers: string;
    rowsPerPage: string;
    save: string;
    search: string;
    select: string;
    selectedCountOfRowCountRowsSelected: string;
    showAll: string;
    showAllColumns: string;
    showHideColumns: string;
    showHideFilters: string;
    showHideSearch: string;
    sortByColumnAsc: string;
    sortByColumnDesc: string;
    sortedByColumnAsc: string;
    sortedByColumnDesc: string;
    thenBy: string;
    toggleDensity: string;
    toggleFullScreen: string;
    toggleSelectAll: string;
    toggleSelectRow: string;
    toggleVisibility: string;
    ungroupByColumn: string;
    unpin: string;
    unpinAll: string;
}
interface MRT_RowModel<TData extends MRT_RowData> {
    flatRows: MRT_Row<TData>[];
    rows: MRT_Row<TData>[];
    rowsById: {
        [key: string]: MRT_Row<TData>;
    };
}
type MRT_TableInstance<TData extends MRT_RowData> = Omit<Table<TData>, 'getAllColumns' | 'getAllFlatColumns' | 'getAllLeafColumns' | 'getBottomRows' | 'getCenterLeafColumns' | 'getCenterRows' | 'getColumn' | 'getExpandedRowModel' | 'getFlatHeaders' | 'getHeaderGroups' | 'getLeftLeafColumns' | 'getPaginationRowModel' | 'getPreFilteredRowModel' | 'getPrePaginationRowModel' | 'getRightLeafColumns' | 'getRowModel' | 'getSelectedRowModel' | 'getState' | 'getTopRows' | 'options'> & {
    getAllColumns: () => MRT_Column<TData>[];
    getAllFlatColumns: () => MRT_Column<TData>[];
    getAllLeafColumns: () => MRT_Column<TData>[];
    getBottomRows: () => MRT_Row<TData>[];
    getCenterLeafColumns: () => MRT_Column<TData>[];
    getCenterRows: () => MRT_Row<TData>[];
    getColumn: (columnId: string) => MRT_Column<TData>;
    getExpandedRowModel: () => MRT_RowModel<TData>;
    getFlatHeaders: () => MRT_Header<TData>[];
    getHeaderGroups: () => MRT_HeaderGroup<TData>[];
    getLeftLeafColumns: () => MRT_Column<TData>[];
    getPaginationRowModel: () => MRT_RowModel<TData>;
    getPreFilteredRowModel: () => MRT_RowModel<TData>;
    getPrePaginationRowModel: () => MRT_RowModel<TData>;
    getRightLeafColumns: () => MRT_Column<TData>[];
    getRowModel: () => MRT_RowModel<TData>;
    getSelectedRowModel: () => MRT_RowModel<TData>;
    getState: () => MRT_TableState<TData>;
    getTopRows: () => MRT_Row<TData>[];
    options: MRT_DefinedTableOptions<TData>;
    refs: {
        bottomToolbarRef: MutableRefObject<HTMLDivElement>;
        editInputRefs: MutableRefObject<Record<string, HTMLInputElement>>;
        filterInputRefs: MutableRefObject<Record<string, HTMLInputElement>>;
        searchInputRef: MutableRefObject<HTMLInputElement>;
        tableContainerRef: MutableRefObject<HTMLDivElement>;
        tableHeadCellRefs: MutableRefObject<Record<string, HTMLTableCellElement>>;
        tablePaperRef: MutableRefObject<HTMLDivElement>;
        topToolbarRef: MutableRefObject<HTMLDivElement>;
        tableFooterRef: MutableRefObject<HTMLTableSectionElement>;
        tableHeadRef: MutableRefObject<HTMLTableSectionElement>;
    };
    setCreatingRow: Dispatch<SetStateAction<MRT_Row<TData> | null | true>>;
    setColumnFilterFns: Dispatch<SetStateAction<MRT_ColumnFilterFnsState>>;
    setDensity: Dispatch<SetStateAction<MRT_DensityState>>;
    setDraggingColumn: Dispatch<SetStateAction<MRT_Column<TData> | null>>;
    setDraggingRow: Dispatch<SetStateAction<MRT_Row<TData> | null>>;
    setEditingCell: Dispatch<SetStateAction<MRT_Cell<TData> | null>>;
    setEditingRow: Dispatch<SetStateAction<MRT_Row<TData> | null>>;
    setGlobalFilterFn: Dispatch<SetStateAction<MRT_FilterOption>>;
    setHoveredColumn: Dispatch<SetStateAction<MRT_Column<TData> | {
        id: string;
    } | null>>;
    setHoveredRow: Dispatch<SetStateAction<MRT_Row<TData> | {
        id: string;
    } | null>>;
    setIsFullScreen: Dispatch<SetStateAction<boolean>>;
    setShowAlertBanner: Dispatch<SetStateAction<boolean>>;
    setShowColumnFilters: Dispatch<SetStateAction<boolean>>;
    setShowGlobalFilter: Dispatch<SetStateAction<boolean>>;
    setShowToolbarDropZone: Dispatch<SetStateAction<boolean>>;
};
type MRT_DefinedTableOptions<TData extends MRT_RowData> = MRT_TableOptions<TData> & {
    localization: MRT_Localization;
    icons: MRT_Icons;
};
type MRT_TableState<TData extends MRT_RowData> = Prettify<TableState & {
    columnFilterFns: MRT_ColumnFilterFnsState;
    creatingRow: MRT_Row<TData> | null;
    density: MRT_DensityState;
    draggingColumn: MRT_Column<TData> | null;
    draggingRow: MRT_Row<TData> | null;
    editingCell: MRT_Cell<TData> | null;
    editingRow: MRT_Row<TData> | null;
    globalFilterFn: MRT_FilterOption;
    hoveredColumn: MRT_Column<TData> | {
        id: string;
    } | null;
    hoveredRow: MRT_Row<TData> | {
        id: string;
    } | null;
    isFullScreen: boolean;
    isLoading: boolean;
    isSaving: boolean;
    showAlertBanner: boolean;
    showColumnFilters: boolean;
    showGlobalFilter: boolean;
    showLoadingOverlay: boolean;
    showProgressBars: boolean;
    showSkeletons: boolean;
    showToolbarDropZone: boolean;
}>;
type MRT_ColumnDef<TData extends MRT_RowData, TValue = unknown> = Omit<ColumnDef<TData, TValue>, 'accessorKey' | 'aggregatedCell' | 'aggregationFn' | 'cell' | 'columns' | 'filterFn' | 'footer' | 'header' | 'id' | 'sortingFn'> & {
    AggregatedCell?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Cell?: (props: {
        cell: MRT_Cell<TData, TValue>;
        renderedCellValue: number | string | ReactNode;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        rowRef?: RefObject<HTMLTableRowElement>;
        table: MRT_TableInstance<TData>;
        staticRowIndex?: number;
    }) => ReactNode;
    Edit?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Filter?: (props: {
        column: MRT_Column<TData, TValue>;
        header: MRT_Header<TData>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Footer?: ReactNode | ((props: {
        column: MRT_Column<TData, TValue>;
        footer: MRT_Header<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode);
    GroupedCell?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    Header?: ReactNode | ((props: {
        column: MRT_Column<TData, TValue>;
        header: MRT_Header<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode);
    PlaceholderCell?: (props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    /**
     * Either an `accessorKey` or a combination of an `accessorFn` and `id` are required for a data column definition.
     * Specify a function here to point to the correct property in the data object.
     *
     * @example accessorFn: (row) => row.username
     */
    accessorFn?: (originalRow: TData) => any;
    /**
     * Either an `accessorKey` or a combination of an `accessorFn` and `id` are required for a data column definition.
     * Specify which key in the row this column should use to access the correct data.
     * Also supports Deep Key Dot Notation.
     *
     * @example accessorKey: 'username' //simple
     * @example accessorKey: 'name.firstName' //deep key dot notation
     */
    accessorKey?: DeepKeys<TData> | (string & {});
    aggregationFn?: MRT_AggregationFn<TData> | Array<MRT_AggregationFn<TData>>;
    /**
     * Specify what type of column this is. Either `data`, `display`, or `group`. Defaults to `data`.
     * Leave this blank if you are just creating a normal data column.
     *
     * @default 'data'
     *
     * @example columnDefType: 'display'
     */
    columnDefType?: 'data' | 'display' | 'group';
    columnFilterModeOptions?: Array<LiteralUnion<string & MRT_FilterOption>> | null;
    columns?: MRT_ColumnDef<TData>[];
    editVariant?: 'text' | 'select';
    enableClickToCopy?: boolean;
    enableColumnActions?: boolean;
    enableColumnDragging?: boolean;
    enableColumnFilterModes?: boolean;
    enableColumnOrdering?: boolean;
    enableEditing?: boolean | ((row: MRT_Row<TData>) => boolean);
    enableFilterMatchHighlighting?: boolean;
    filterFn?: MRT_FilterFn<TData>;
    filterVariant?: 'autocomplete' | 'checkbox' | 'date' | 'date-range' | 'multi-select' | 'range' | 'range-slider' | 'select' | 'text';
    /**
     * footer must be a string. If you want custom JSX to render the footer, you can also specify a `Footer` option. (Capital F)
     */
    footer?: string;
    /**
     * header must be a string. If you want custom JSX to render the header, you can also specify a `Header` option. (Capital H)
     */
    header: string;
    /**
     * Either an `accessorKey` or a combination of an `accessorFn` and `id` are required for a data column definition.
     *
     * If you have also specified an `accessorFn`, MRT still needs to have a valid `id` to be able to identify the column uniquely.
     *
     * `id` defaults to the `accessorKey` or `header` if not specified.
     *
     * @default gets set to the same value as `accessorKey` by default
     */
    id?: LiteralUnion<string & keyof TData>;
    mantineColumnActionsButtonProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, TValue>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineColumnDragHandleProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, TValue>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineCopyButtonProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<UnstyledButtonProps>) | ((props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<UnstyledButtonProps>);
    mantineEditSelectProps?: (HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>) | ((props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>);
    mantineEditTextInputProps?: (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | ((props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineFilterAutocompleteProps?: (HTMLPropsRef<HTMLInputElement> & Partial<AutocompleteProps>) | ((props: {
        column: MRT_Column<TData, TValue>;
        table: MRT_TableInstance<TData>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<AutocompleteProps>);
    mantineFilterCheckboxProps?: (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | ((props: {
        column: MRT_Column<TData, TValue>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineFilterDateInputProps?: (HTMLPropsRef<HTMLInputElement> & Partial<DateInputProps>) | ((props: {
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<DateInputProps>);
    mantineFilterMultiSelectProps?: (HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>);
    mantineFilterRangeSliderProps?: (HTMLPropsRef<HTMLInputElement> & Partial<RangeSliderProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<RangeSliderProps>);
    mantineFilterSelectProps?: (HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>);
    mantineFilterTextInputProps?: (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, TValue>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineTableBodyCellProps?: (HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment) | ((props: {
        cell: MRT_Cell<TData, TValue>;
        column: MRT_Column<TData, TValue>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment);
    mantineTableFooterCellProps?: (HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, TValue>;
    }) => HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment);
    mantineTableHeadCellProps?: (HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, TValue>;
    }) => HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment);
    renderColumnActionsMenuItems?: (props: {
        column: MRT_Column<TData, TValue>;
        table: MRT_TableInstance<TData>;
        internalColumnMenuItems: ReactNode;
    }) => ReactNode;
    renderColumnFilterModeMenuItems?: (props: {
        column: MRT_Column<TData, TValue>;
        internalFilterOptions: MRT_InternalFilterOption[];
        onSelectFilterMode: (filterMode: MRT_FilterOption) => void;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    sortingFn?: MRT_SortingFn<TData>;
    visibleInShowHideMenu?: boolean;
};
type MRT_DisplayColumnDef<TData extends MRT_RowData, TValue = unknown> = Omit<MRT_ColumnDef<TData, TValue>, 'accessorFn' | 'accessorKey'>;
type MRT_GroupColumnDef<TData extends MRT_RowData> = MRT_DisplayColumnDef<TData, any> & {
    columns: MRT_ColumnDef<TData>[];
};
type MRT_DefinedColumnDef<TData extends MRT_RowData, TValue = unknown> = Omit<MRT_ColumnDef<TData, TValue>, 'defaultDisplayColumn' | 'id'> & {
    _filterFn: MRT_FilterOption;
    defaultDisplayColumn: Partial<MRT_ColumnDef<TData, TValue>>;
    id: string;
};
type MRT_Column<TData extends MRT_RowData, TValue = unknown> = Omit<Column<TData, unknown>, 'header' | 'footer' | 'columns' | 'columnDef' | 'filterFn'> & {
    columnDef: MRT_DefinedColumnDef<TData, TValue>;
    columns?: MRT_Column<TData>[];
    filterFn?: MRT_FilterFn<TData>;
    footer: string;
    header: string;
};
type MRT_Header<TData extends MRT_RowData, TValue = unknown> = Omit<Header<TData, unknown>, 'column'> & {
    column: MRT_Column<TData, TValue>;
};
type MRT_HeaderGroup<TData extends MRT_RowData> = Omit<HeaderGroup<TData>, 'headers'> & {
    headers: MRT_Header<TData>[];
};
type MRT_Row<TData extends MRT_RowData> = Omit<Row<TData>, 'getVisibleCells' | 'getAllCells' | 'subRows' | '_valuesCache'> & {
    getAllCells: () => MRT_Cell<TData>[];
    getVisibleCells: () => MRT_Cell<TData>[];
    subRows?: MRT_Row<TData>[];
    _valuesCache: Record<LiteralUnion<string & DeepKeys<TData>>, any>;
};
type MRT_Cell<TData extends MRT_RowData, TValue = unknown> = Omit<Cell<TData, TValue>, 'column' | 'row'> & {
    column: MRT_Column<TData, TValue>;
    row: MRT_Row<TData>;
};
type MRT_AggregationOption = string & keyof typeof MRT_AggregationFns;
type MRT_AggregationFn<TData extends MRT_RowData> = AggregationFn<TData> | MRT_AggregationOption;
type MRT_SortingOption = LiteralUnion<string & keyof typeof MRT_SortingFns>;
type MRT_SortingFn<TData extends MRT_RowData> = SortingFn<TData> | MRT_SortingOption;
type MRT_FilterOption = LiteralUnion<string & keyof typeof MRT_FilterFns>;
type MRT_FilterFn<TData extends MRT_RowData> = FilterFn<TData> | MRT_FilterOption;
type MRT_InternalFilterOption = {
    divider: boolean;
    label: string;
    option: string;
    symbol: string;
};
type MRT_DisplayColumnIds = 'mrt-row-actions' | 'mrt-row-drag' | 'mrt-row-expand' | 'mrt-row-numbers' | 'mrt-row-pin' | 'mrt-row-select' | 'mrt-row-spacer';
type MRT_CreateTableFeature<TData extends MRT_RowData, TFeature = any> = (table: MRT_TableInstance<TData>) => TFeature;
/**
 * `columns` and `data` props are the only required props, but there are over 150 other optional props.
 *
 * See more info on creating columns and data on the official docs site:
 * @link https://www.mantine-react-table.com/docs/getting-started/usage
 *
 * See the full props list on the official docs site:
 * @link https://www.mantine-react-table.com/docs/api/table-options
 */
type MRT_TableOptions<TData extends MRT_RowData> = Omit<Partial<TableOptions<TData>>, 'columns' | 'data' | 'defaultColumn' | 'enableRowSelection' | 'expandRowsFn' | 'getRowId' | 'globalFilterFn' | 'initialState' | 'onStateChange' | 'state'> & {
    columnFilterModeOptions?: Array<LiteralUnion<string & MRT_FilterOption>> | null;
    /**
     * The columns to display in the table. `accessorKey`s or `accessorFn`s must match keys in the `data` prop.
     *
     * See more info on creating columns on the official docs site:
     * @link https://www.mantine-react-table.com/docs/guides/data-columns
     * @link https://www.mantine-react-table.com/docs/guides/display-columns
     *
     * See all Columns Options on the official docs site:
     * @link https://www.mantine-react-table.com/docs/api/column-options
     */
    columns: MRT_ColumnDef<TData>[];
    columnVirtualizerInstanceRef?: MutableRefObject<Virtualizer<HTMLDivElement, HTMLTableCellElement> | null>;
    columnVirtualizerOptions?: Partial<VirtualizerOptions<HTMLDivElement, HTMLTableCellElement>> | ((props: {
        table: MRT_TableInstance<TData>;
    }) => Partial<VirtualizerOptions<HTMLDivElement, HTMLTableCellElement>>);
    /**
     * Pass your data as an array of objects. Objects can theoretically be any shape, but it's best to keep them consistent.
     *
     * See the usage guide for more info on creating columns and data:
     * @link https://www.mantine-react-table.com/docs/getting-started/usage
     */
    data: TData[];
    /**
     * Instead of specifying a bunch of the same options for each column, you can just change an option in the `defaultColumn` prop to change a default option for all columns.
     */
    defaultColumn?: Partial<MRT_ColumnDef<TData>>;
    /**
     * Change the default options for display columns.
     */
    defaultDisplayColumn?: Partial<MRT_ColumnDef<TData>>;
    displayColumnDefOptions?: Partial<{
        [key in MRT_DisplayColumnIds]: Partial<MRT_ColumnDef<TData>>;
    }>;
    createDisplayMode?: 'modal' | 'row' | 'custom';
    editDisplayMode?: 'modal' | 'row' | 'cell' | 'table' | 'custom';
    columnFilterDisplayMode?: 'subheader' | 'popover' | 'custom';
    paginationDisplayMode?: 'default' | 'pages' | 'custom';
    selectDisplayMode?: 'checkbox' | 'radio' | 'switch';
    enableBottomToolbar?: boolean;
    enableClickToCopy?: boolean;
    enableColumnActions?: boolean;
    enableColumnDragging?: boolean;
    enableColumnFilterModes?: boolean;
    enableColumnOrdering?: boolean;
    enableColumnVirtualization?: boolean;
    enableDensityToggle?: boolean;
    enableEditing?: boolean | ((row: MRT_Row<TData>) => boolean);
    enableExpandAll?: boolean;
    enableFacetedValues?: boolean;
    enableFilterMatchHighlighting?: boolean;
    enableFullScreenToggle?: boolean;
    enableGlobalFilterModes?: boolean;
    enableGlobalFilterRankedResults?: boolean;
    enablePagination?: boolean;
    enableRowActions?: boolean;
    enableRowDragging?: boolean;
    enableRowNumbers?: boolean;
    enableRowOrdering?: boolean;
    enableRowSelection?: boolean | ((row: MRT_Row<TData>) => boolean);
    enableRowVirtualization?: boolean;
    enableSelectAll?: boolean;
    enableStickyFooter?: boolean;
    enableStickyHeader?: boolean;
    enableTableFooter?: boolean;
    enableTableHead?: boolean;
    enableToolbarInternalActions?: boolean;
    enableTopToolbar?: boolean;
    expandRowsFn?: (dataRow: TData) => TData[];
    getRowId?: (originalRow: TData, index: number, parentRow: MRT_Row<TData>) => string | undefined;
    globalFilterFn?: MRT_FilterOption;
    globalFilterModeOptions?: MRT_FilterOption[] | null;
    icons?: Partial<MRT_Icons>;
    initialState?: Partial<MRT_TableState<TData>>;
    /**
     * Changes which kind of CSS layout is used to render the table. `semantic` uses default semantic HTML elements, while `grid` adds CSS grid and flexbox styles
     */
    layoutMode?: 'semantic' | 'grid' | 'grid-no-grow';
    /**
     * Pass in either a locale imported from `mantine-react-table/locales/*` or a custom locale object.
     *
     * See the localization (i18n) guide for more info:
     * @link https://www.mantine-react-table.com/docs/guides/localization
     */
    localization?: Partial<MRT_Localization>;
    mantineBottomToolbarProps?: (HTMLPropsRef<HTMLDivElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & BoxProps);
    mantineColumnActionsButtonProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, unknown>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineColumnDragHandleProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, unknown>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineCopyButtonProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<UnstyledButtonProps>) | ((props: {
        cell: MRT_Cell<TData, unknown>;
        column: MRT_Column<TData, unknown>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<UnstyledButtonProps>);
    mantineCreateRowModalProps?: (HTMLPropsRef<HTMLDivElement> & Partial<ModalProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        row: MRT_Row<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<ModalProps>);
    mantineDetailPanelProps?: (HTMLPropsRef<HTMLTableCellElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
        row: MRT_Row<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & BoxProps);
    mantineEditRowModalProps?: (HTMLPropsRef<HTMLDivElement> & Partial<ModalProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        row: MRT_Row<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<ModalProps>);
    mantineEditSelectProps?: (HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>) | ((props: {
        cell: MRT_Cell<TData, unknown>;
        column: MRT_Column<TData, unknown>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>);
    mantineEditTextInputProps?: (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | ((props: {
        cell: MRT_Cell<TData, unknown>;
        column: MRT_Column<TData, unknown>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineExpandAllButtonProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineExpandButtonProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        row: MRT_Row<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineFilterAutocompleteProps?: (HTMLPropsRef<HTMLInputElement> & Partial<AutocompleteProps>) | ((props: {
        column: MRT_Column<TData, unknown>;
        table: MRT_TableInstance<TData>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<AutocompleteProps>);
    mantineFilterCheckboxProps?: (HTMLPropsRef<HTMLInputElement> & Partial<CheckboxProps>) | ((props: {
        column: MRT_Column<TData, unknown>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<CheckboxProps>);
    mantineFilterDateInputProps?: (HTMLPropsRef<HTMLInputElement> & Partial<DateInputProps>) | ((props: {
        column: MRT_Column<TData, unknown>;
        rangeFilterIndex?: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<DateInputProps>);
    mantineFilterMultiSelectProps?: (HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, unknown>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<MultiSelectProps>);
    mantineFilterRangeSliderProps?: (HTMLPropsRef<HTMLInputElement> & Partial<RangeSliderProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, unknown>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<RangeSliderProps>);
    mantineFilterSelectProps?: (HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, unknown>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<SelectProps>);
    mantineFilterTextInputProps?: (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, unknown>;
        rangeFilterIndex?: number;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineHighlightProps?: (HTMLPropsRef<HTMLSpanElement> & Partial<HighlightProps>) | ((props: {
        cell: MRT_Cell<TData, unknown>;
        column: MRT_Column<TData, unknown>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLSpanElement> & Partial<HighlightProps>);
    mantineLoadingOverlayProps?: (HTMLPropsRef<HTMLDivElement> & Partial<LoadingOverlayProps>) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<LoadingOverlayProps>);
    mantineProgressProps?: (HTMLPropsRef<HTMLDivElement> & ProgressProps) | ((props: {
        isTopToolbar: boolean;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & ProgressProps);
    mantinePaginationProps?: Partial<HTMLPropsRef<HTMLDivElement> & MRT_PaginationProps> | ((props: {
        table: MRT_TableInstance<TData>;
    }) => Partial<HTMLPropsRef<HTMLDivElement> & MRT_PaginationProps>);
    mantinePaperProps?: (HTMLPropsRef<HTMLDivElement> & PaperProps) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & PaperProps);
    mantineRowDragHandleProps?: (HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>) | ((props: {
        table: MRT_TableInstance<TData>;
        row: MRT_Row<TData>;
    }) => HTMLPropsRef<HTMLButtonElement> & Partial<ActionIconProps>);
    mantineSearchTextInputProps?: (HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & Partial<TextInputProps>);
    mantineSelectAllCheckboxProps?: (HTMLPropsRef<HTMLInputElement> & (CheckboxProps | RadioProps | SwitchProps)) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & (CheckboxProps | RadioProps | SwitchProps));
    mantineSelectCheckboxProps?: (HTMLPropsRef<HTMLInputElement> & (CheckboxProps | RadioProps | SwitchProps)) | ((props: {
        table: MRT_TableInstance<TData>;
        staticRowIndex?: number;
        row: MRT_Row<TData>;
    }) => HTMLPropsRef<HTMLInputElement> & (CheckboxProps | RadioProps | SwitchProps));
    mantineSkeletonProps?: (HTMLPropsRef<HTMLDivElement> & SkeletonProps) | ((props: {
        cell: MRT_Cell<TData, unknown>;
        column: MRT_Column<TData, unknown>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & SkeletonProps);
    mantineTableBodyCellProps?: (HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment) | ((props: {
        cell: MRT_Cell<TData, unknown>;
        column: MRT_Column<TData, unknown>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment);
    mantineTableBodyProps?: (HTMLPropsRef<HTMLTableSectionElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableSectionElement> & BoxProps);
    mantineTableBodyRowProps?: (HTMLPropsRef<HTMLTableRowElement> & BoxProps) | ((props: {
        isDetailPanel?: boolean;
        row: MRT_Row<TData>;
        staticRowIndex: number;
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableRowElement> & BoxProps);
    mantineTableContainerProps?: (HTMLPropsRef<HTMLDivElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & BoxProps);
    mantineTableFooterCellProps?: (HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, unknown>;
    }) => HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment);
    mantineTableFooterProps?: (HTMLPropsRef<HTMLTableSectionElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableSectionElement> & BoxProps);
    mantineTableFooterRowProps?: (HTMLPropsRef<HTMLTableRowElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
        footerGroup: MRT_HeaderGroup<TData>;
    }) => HTMLPropsRef<HTMLTableRowElement> & BoxProps);
    mantineTableHeadCellProps?: (HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment) | ((props: {
        table: MRT_TableInstance<TData>;
        column: MRT_Column<TData, unknown>;
    }) => HTMLPropsRef<HTMLTableCellElement> & BoxProps & ColumnAlignment);
    mantineTableHeadProps?: (HTMLPropsRef<HTMLTableSectionElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableSectionElement> & BoxProps);
    mantineTableHeadRowProps?: (HTMLPropsRef<HTMLTableRowElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
        headerGroup: MRT_HeaderGroup<TData>;
    }) => HTMLPropsRef<HTMLTableRowElement> & BoxProps);
    mantineTableProps?: (HTMLPropsRef<HTMLTableElement> & TableProps) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLTableElement> & TableProps);
    mantineToolbarAlertBannerBadgeProps?: (HTMLPropsRef<HTMLDivElement> & Partial<BadgeProps>) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<BadgeProps>);
    mantineToolbarAlertBannerProps?: (HTMLPropsRef<HTMLDivElement> & Partial<AlertProps>) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & Partial<AlertProps>);
    mantineTopToolbarProps?: (HTMLPropsRef<HTMLDivElement> & BoxProps) | ((props: {
        table: MRT_TableInstance<TData>;
    }) => HTMLPropsRef<HTMLDivElement> & BoxProps);
    /**
     * Memoize cells, rows, or the entire table body to potentially improve render performance.
     *
     * @warning This will break some dynamic rendering features. See the memoization guide for more info:
     * @link https://www.mantine-react-table.com/docs/guides/memoize-components
     */
    memoMode?: 'cells' | 'rows' | 'table-body';
    onCreatingRowCancel?: (props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => void;
    onCreatingRowChange?: OnChangeFn<MRT_Row<TData> | null>;
    onCreatingRowSave?: (props: {
        exitCreatingMode: () => void;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
        values: Record<LiteralUnion<string & DeepKeys<TData>>, any>;
    }) => void;
    onColumnFilterFnsChange?: OnChangeFn<{
        [key: string]: MRT_FilterOption;
    }>;
    onDensityChange?: OnChangeFn<MRT_DensityState>;
    onDraggingColumnChange?: OnChangeFn<MRT_Column<TData> | null>;
    onDraggingRowChange?: OnChangeFn<MRT_Row<TData> | null>;
    onEditingCellChange?: OnChangeFn<MRT_Cell<TData> | null>;
    onEditingRowCancel?: (props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => void;
    onEditingRowChange?: OnChangeFn<MRT_Row<TData> | null>;
    onEditingRowSave?: (props: {
        exitEditingMode: () => void;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
        values: Record<LiteralUnion<string & DeepKeys<TData>>, any>;
    }) => Promise<void> | void;
    onGlobalFilterFnChange?: OnChangeFn<MRT_FilterOption>;
    onHoveredColumnChange?: OnChangeFn<MRT_Column<TData> | {
        id: string;
    } | null>;
    onHoveredRowChange?: OnChangeFn<MRT_Row<TData> | {
        id: string;
    } | null>;
    onIsFullScreenChange?: OnChangeFn<boolean>;
    onShowAlertBannerChange?: OnChangeFn<boolean>;
    onShowColumnFiltersChange?: OnChangeFn<boolean>;
    onShowGlobalFilterChange?: OnChangeFn<boolean>;
    onShowToolbarDropZoneChange?: OnChangeFn<boolean>;
    positionActionsColumn?: 'first' | 'last';
    positionExpandColumn?: 'first' | 'last';
    positionGlobalFilter?: 'left' | 'right' | 'none';
    positionPagination?: 'bottom' | 'top' | 'both' | 'none';
    positionToolbarAlertBanner?: 'bottom' | 'top' | 'head-overlay' | 'none';
    positionToolbarDropZone?: 'bottom' | 'top' | 'none' | 'both';
    renderBottomToolbar?: ReactNode | ((props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode);
    renderBottomToolbarCustomActions?: (props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderCreateRowModalContent?: (props: {
        internalEditComponents: ReactNode[];
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderColumnActionsMenuItems?: (props: {
        column: MRT_Column<TData, unknown>;
        table: MRT_TableInstance<TData>;
        internalColumnMenuItems: ReactNode;
    }) => ReactNode;
    renderColumnFilterModeMenuItems?: (props: {
        column: MRT_Column<TData, unknown>;
        internalFilterOptions: MRT_InternalFilterOption[];
        onSelectFilterMode: (filterMode: MRT_FilterOption) => void;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderDetailPanel?: (props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderEditRowModalContent?: (props: {
        internalEditComponents: ReactNode[];
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderGlobalFilterModeMenuItems?: (props: {
        internalFilterOptions: MRT_InternalFilterOption[];
        onSelectFilterMode: (filterMode: MRT_FilterOption) => void;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderEmptyRowsFallback?: (props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderRowActionMenuItems?: (props: {
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderRowActions?: (props: {
        cell: MRT_Cell<TData, unknown>;
        row: MRT_Row<TData>;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderToolbarAlertBannerContent?: (props: {
        groupedAlert: ReactNode | null;
        selectedAlert: ReactNode | null;
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderToolbarInternalActions?: (props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    renderTopToolbar?: ReactNode | ((props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode);
    renderTopToolbarCustomActions?: (props: {
        table: MRT_TableInstance<TData>;
    }) => ReactNode;
    rowCount?: number;
    rowNumberDisplayMode?: 'original' | 'static';
    rowPinningDisplayMode?: 'bottom' | 'select-bottom' | 'select-sticky' | 'select-top' | 'sticky' | 'top' | 'top-and-bottom';
    rowVirtualizerInstanceRef?: MutableRefObject<Virtualizer<HTMLDivElement, HTMLTableRowElement> | null>;
    rowVirtualizerOptions?: Partial<VirtualizerOptions<HTMLDivElement, HTMLTableRowElement>> | ((props: {
        table: MRT_TableInstance<TData>;
    }) => Partial<VirtualizerOptions<HTMLDivElement, HTMLTableRowElement>>);
    selectAllMode?: 'all' | 'page';
    /**
     * Manage state externally any way you want, then pass it back into MRT.
     */
    state?: Partial<MRT_TableState<TData>>;
};

type TableInstanceProp<TData extends MRT_RowData> = {
    table: MRT_TableInstance<TData>;
};
type Props$P<TData extends MRT_RowData> = Xor<TableInstanceProp<TData>, MRT_TableOptions<TData>>;
declare const MantineReactTable: <TData extends MRT_RowData>(props: Props$P<TData>) => react_jsx_runtime.JSX.Element;

interface Props$O<TData extends MRT_RowData> {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    enableHover?: boolean;
    isStriped?: boolean | 'odd' | 'even';
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableBody: <TData extends MRT_RowData>({ columnVirtualizer, enableHover, isStriped, table, }: Props$O<TData>) => react_jsx_runtime.JSX.Element;
declare const Memo_MRT_TableBody: <TData extends MRT_RowData>({ columnVirtualizer, enableHover, isStriped, table, }: Props$O<TData>) => react_jsx_runtime.JSX.Element;

interface Props$N<TData extends MRT_RowData, TValue = MRT_CellValue> {
    cell: MRT_Cell<TData, TValue>;
    isStriped?: boolean | 'odd' | 'even';
    measureElement?: (element: HTMLTableCellElement) => void;
    numRows?: number;
    rowIndex: number;
    rowRef: RefObject<HTMLTableRowElement>;
    table: MRT_TableInstance<TData>;
    virtualCell?: MRT_VirtualItem;
}
declare const MRT_TableBodyCell: <TData extends MRT_RowData>({ cell, isStriped, measureElement, numRows, rowIndex, rowRef, table, virtualCell, }: Props$N<TData, unknown>) => react_jsx_runtime.JSX.Element;
declare const Memo_MRT_TableBodyCell: <TData extends MRT_RowData>({ cell, isStriped, measureElement, numRows, rowIndex, rowRef, table, virtualCell, }: Props$N<TData, unknown>) => react_jsx_runtime.JSX.Element;

interface Props$M<TData extends MRT_RowData, TValue = MRT_CellValue> {
    cell: MRT_Cell<TData, TValue>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableBodyCellValue: <TData extends MRT_RowData>({ cell, table, }: Props$M<TData, unknown>) => react.ReactNode;

interface Props$L<TData extends MRT_RowData> {
    columnVirtualizer?: MRT_ColumnVirtualizer;
    enableHover?: boolean;
    isStriped?: boolean | 'odd' | 'even';
    measureElement?: (element: HTMLTableRowElement) => void;
    numRows?: number;
    pinnedRowIds?: string[];
    row: MRT_Row<TData>;
    rowIndex: number;
    table: MRT_TableInstance<TData>;
    virtualRow?: MRT_VirtualItem;
}
declare const MRT_TableBodyRow: <TData extends MRT_RowData>({ columnVirtualizer, enableHover, isStriped, measureElement, numRows, row, rowIndex, table, pinnedRowIds, virtualRow, }: Props$L<TData>) => react_jsx_runtime.JSX.Element;
declare const Memo_MRT_TableBodyRow: <TData extends MRT_RowData>({ columnVirtualizer, enableHover, isStriped, measureElement, numRows, row, rowIndex, table, pinnedRowIds, virtualRow, }: Props$L<TData>) => react_jsx_runtime.JSX.Element;

interface Props$K<TData extends MRT_RowData> {
    row: MRT_Row<TData>;
    rowRef: RefObject<HTMLTableRowElement>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableBodyRowGrabHandle: <TData extends MRT_RowData>({ row, rowRef, table, }: Props$K<TData>) => react_jsx_runtime.JSX.Element;

interface Props$J<TData extends MRT_RowData> {
    parentRowRef: React.RefObject<HTMLTableRowElement>;
    row: MRT_Row<TData>;
    rowIndex: number;
    table: MRT_TableInstance<TData>;
    virtualRow?: MRT_VirtualItem;
}
declare const MRT_TableDetailPanel: <TData extends MRT_RowData>({ parentRowRef, row, rowIndex, table, virtualRow, }: Props$J<TData>) => react_jsx_runtime.JSX.Element;

interface Props$I<TData extends MRT_RowData, TValue = MRT_CellValue> {
    column: MRT_Column<TData, TValue>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ColumnPinningButtons: <TData extends MRT_RowData>({ column, table: { options: { icons: { IconPinned, IconPinnedOff }, localization, }, }, }: Props$I<TData, unknown>) => react_jsx_runtime.JSX.Element;

interface Props$H<TData extends MRT_RowData, TValue = MRT_CellValue> {
    cell: MRT_Cell<TData, TValue>;
    children: ReactNode;
    table: MRT_TableInstance<TData>;
}
declare const MRT_CopyButton: <TData extends MRT_RowData>({ cell, children, table, }: Props$H<TData, unknown>) => react_jsx_runtime.JSX.Element;

interface Props$G<TData extends MRT_RowData> {
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
    variant?: 'icon' | 'text';
}
declare const MRT_EditActionButtons: <TData extends MRT_RowData>({ row, table, variant, }: Props$G<TData>) => react_jsx_runtime.JSX.Element;

interface Props$F<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ExpandAllButton: <TData extends MRT_RowData>({ table, }: Props$F<TData>) => react_jsx_runtime.JSX.Element;

interface Props$E<TData extends MRT_RowData> {
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ExpandButton: <TData extends MRT_RowData>({ row, table, }: Props$E<TData>) => react_jsx_runtime.JSX.Element;

interface Props$D<TData extends MRT_RowData> {
    actionIconProps?: ActionIconProps & HTMLPropsRef<HTMLButtonElement>;
    onDragStart: DragEventHandler<HTMLButtonElement>;
    onDragEnd: DragEventHandler<HTMLButtonElement>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_GrabHandleButton: <TData extends MRT_RowData>({ actionIconProps, onDragEnd, onDragStart, table: { options: { icons: { IconGripHorizontal }, localization: { move }, }, }, }: Props$D<TData>) => react_jsx_runtime.JSX.Element;

interface Props$C<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ShowHideColumnsButton: <TData extends MRT_RowData>({ table, title, ...rest }: Props$C<TData>) => react_jsx_runtime.JSX.Element;

interface Props$B<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleDensePaddingButton: <TData extends MRT_RowData>({ table: { getState, options: { icons: { IconBaselineDensityLarge, IconBaselineDensityMedium, IconBaselineDensitySmall, }, localization: { toggleDensity }, }, setDensity, }, title, ...rest }: Props$B<TData>) => react_jsx_runtime.JSX.Element;

interface Props$A<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleFiltersButton: <TData extends MRT_RowData>({ table: { getState, options: { icons: { IconFilter, IconFilterOff }, localization: { showHideFilters }, }, setShowColumnFilters, }, title, ...rest }: Props$A<TData>) => react_jsx_runtime.JSX.Element;

interface Props$z<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleFullScreenButton: <TData extends MRT_RowData>({ table: { getState, options: { icons: { IconMinimize, IconMaximize }, localization: { toggleFullScreen }, }, setIsFullScreen, }, title, ...rest }: Props$z<TData>) => react_jsx_runtime.JSX.Element;

interface Props$y<TData extends MRT_RowData> extends ActionIconProps, HTMLPropsRef<HTMLButtonElement> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleGlobalFilterButton: <TData extends MRT_RowData>({ table: { getState, options: { icons: { IconSearch, IconSearchOff }, localization: { showHideSearch }, }, refs: { searchInputRef }, setShowGlobalFilter, }, title, ...rest }: Props$y<TData>) => react_jsx_runtime.JSX.Element;

interface Props$x<TData extends MRT_RowData, TValue = MRT_CellValue> {
    cell: MRT_Cell<TData, TValue>;
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToggleRowActionMenuButton: <TData extends MRT_RowData>({ cell, row, table, }: Props$x<TData, unknown>) => react_jsx_runtime.JSX.Element;

declare const getColumnId: <TData extends MRT_RowData>(columnDef: MRT_ColumnDef<TData>) => string;
declare const getAllLeafColumnDefs: <TData extends MRT_RowData>(columns: MRT_ColumnDef<TData>[]) => MRT_ColumnDef<TData>[];
declare const prepareColumns: <TData extends MRT_RowData>({ aggregationFns, columnDefs, columnFilterFns, defaultDisplayColumn, filterFns, sortingFns, }: {
    aggregationFns: {
        sum: _tanstack_react_table.AggregationFn<any>;
        min: _tanstack_react_table.AggregationFn<any>;
        max: _tanstack_react_table.AggregationFn<any>;
        extent: _tanstack_react_table.AggregationFn<any>;
        mean: _tanstack_react_table.AggregationFn<any>;
        median: _tanstack_react_table.AggregationFn<any>;
        unique: _tanstack_react_table.AggregationFn<any>;
        uniqueCount: _tanstack_react_table.AggregationFn<any>;
        count: _tanstack_react_table.AggregationFn<any>;
    } & Record<string, _tanstack_react_table.AggregationFn<any>>;
    columnDefs: MRT_ColumnDef<TData>[];
    columnFilterFns: {
        [key: string]: MRT_FilterOption;
    };
    defaultDisplayColumn: Partial<MRT_ColumnDef<TData>>;
    filterFns: {
        between: {
            <TData_1 extends MRT_RowData>(row: Row<TData_1>, id: string, filterValues: [string | number, string | number]): boolean;
            autoRemove(val: any): boolean;
        };
        betweenInclusive: {
            <TData_2 extends MRT_RowData>(row: Row<TData_2>, id: string, filterValues: [string | number, string | number]): boolean;
            autoRemove(val: any): boolean;
        };
        contains: {
            <TData_3 extends MRT_RowData>(row: Row<TData_3>, id: string, filterValue: string | number): boolean;
            autoRemove(val: any): boolean;
        };
        empty: {
            <TData_4 extends MRT_RowData>(row: Row<TData_4>, id: string, _filterValue: string | number): boolean;
            autoRemove(val: any): boolean;
        };
        endsWith: {
            <TData_5 extends MRT_RowData>(row: Row<TData_5>, id: string, filterValue: string | number): boolean;
            autoRemove(val: any): boolean;
        };
        equals: {
            <TData_6 extends MRT_RowData>(row: Row<TData_6>, id: string, filterValue: string | number | null): boolean;
            autoRemove(val: any): boolean;
        };
        fuzzy: {
            <TData_7 extends MRT_RowData>(row: Row<TData_7>, columnId: string, filterValue: string | number, addMeta: (item: _tanstack_match_sorter_utils.RankingInfo) => void): boolean;
            autoRemove(val: any): boolean;
        };
        greaterThan: {
            <TData_8 extends MRT_RowData>(row: Row<TData_8>, id: string, filterValue: string | number | null): boolean;
            autoRemove(val: any): boolean;
        };
        greaterThanOrEqualTo: {
            <TData_9 extends MRT_RowData>(row: Row<TData_9>, id: string, filterValue: string | number): boolean;
            autoRemove(val: any): boolean;
        };
        lessThan: {
            <TData_10 extends MRT_RowData>(row: Row<TData_10>, id: string, filterValue: string | number | null): boolean;
            autoRemove(val: any): boolean;
        };
        lessThanOrEqualTo: {
            <TData_11 extends MRT_RowData>(row: Row<TData_11>, id: string, filterValue: string | number): boolean;
            autoRemove(val: any): boolean;
        };
        notEmpty: {
            <TData_12 extends MRT_RowData>(row: Row<TData_12>, id: string, _filterValue: string | number): boolean;
            autoRemove(val: any): boolean;
        };
        notEquals: {
            <TData_13 extends MRT_RowData>(row: Row<TData_13>, id: string, filterValue: string | number): boolean;
            autoRemove(val: any): boolean;
        };
        startsWith: {
            <TData_14 extends MRT_RowData>(row: Row<TData_14>, id: string, filterValue: string | number): boolean;
            autoRemove(val: any): boolean;
        };
        includesString: _tanstack_react_table.FilterFn<any>;
        includesStringSensitive: _tanstack_react_table.FilterFn<any>;
        equalsString: _tanstack_react_table.FilterFn<any>;
        arrIncludes: _tanstack_react_table.FilterFn<any>;
        arrIncludesAll: _tanstack_react_table.FilterFn<any>;
        arrIncludesSome: _tanstack_react_table.FilterFn<any>;
        weakEquals: _tanstack_react_table.FilterFn<any>;
        inNumberRange: _tanstack_react_table.FilterFn<any>;
    } & Record<string, _tanstack_react_table.FilterFn<any>>;
    sortingFns: {
        fuzzy: <TData_15 extends MRT_RowData>(rowA: Row<TData_15>, rowB: Row<TData_15>, columnId: string) => number;
        alphanumeric: _tanstack_react_table.SortingFn<any>;
        alphanumericCaseSensitive: _tanstack_react_table.SortingFn<any>;
        text: _tanstack_react_table.SortingFn<any>;
        textCaseSensitive: _tanstack_react_table.SortingFn<any>;
        datetime: _tanstack_react_table.SortingFn<any>;
        basic: _tanstack_react_table.SortingFn<any>;
    } & Record<string, _tanstack_react_table.SortingFn<any>>;
}) => MRT_DefinedColumnDef<TData>[];
declare const reorderColumn: <TData extends MRT_RowData>(draggedColumn: MRT_Column<TData>, targetColumn: MRT_Column<TData>, columnOrder: _tanstack_react_table.ColumnOrderState) => _tanstack_react_table.ColumnOrderState;
declare const showExpandColumn: <TData extends MRT_RowData>(props: MRT_TableOptions<TData>, grouping?: MRT_GroupingState) => boolean;
declare const getLeadingDisplayColumnIds: <TData extends MRT_RowData>(props: MRT_TableOptions<TData>) => MRT_DisplayColumnIds[];
declare const getTrailingDisplayColumnIds: <TData extends MRT_RowData>(props: MRT_TableOptions<TData>) => MRT_DisplayColumnIds[];
declare const getDefaultColumnOrderIds: <TData extends MRT_RowData>(props: MRT_TableOptions<TData>) => string[];
declare const getDefaultColumnFilterFn: <TData extends MRT_RowData>(columnDef: MRT_ColumnDef<TData>) => MRT_FilterOption;
declare const getIsFirstColumn: <TData extends MRT_RowData>(column: MRT_Column<TData>, table: MRT_TableInstance<TData>) => boolean;
declare const getIsLastColumn: <TData extends MRT_RowData>(column: MRT_Column<TData>, table: MRT_TableInstance<TData>) => boolean;
declare const getIsLastLeftPinnedColumn: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>, column: MRT_Column<TData>) => boolean;
declare const getIsFirstRightPinnedColumn: <TData extends MRT_RowData>(column: MRT_Column<TData>) => boolean;
declare const getTotalRight: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>, column: MRT_Column<TData>) => number;
declare const getCanRankRows: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>) => boolean | undefined;
declare const MRT_DefaultColumn: {
    readonly filterVariant: "text";
    readonly minSize: 40;
    readonly maxSize: 1000;
    readonly size: 180;
};
declare const MRT_DefaultDisplayColumn: {
    readonly columnDefType: "display";
    readonly enableClickToCopy: false;
    readonly enableColumnActions: false;
    readonly enableColumnDragging: false;
    readonly enableColumnFilter: false;
    readonly enableColumnOrdering: false;
    readonly enableEditing: false;
    readonly enableGlobalFilter: false;
    readonly enableGrouping: false;
    readonly enableHiding: false;
    readonly enableResizing: false;
    readonly enableSorting: false;
};
declare function parseFromValuesOrFunc<T, U>(fn: T | ((arg: U) => T) | undefined, arg: U): T | undefined;
declare const parseCSSVarId: (id: string) => string;
declare const getPrimaryShade: (theme: MantineTheme) => number;
declare const getPrimaryColor: (theme: MantineTheme, shade?: MantineShade) => string;
declare const flexRender: (Comp: Renderable<any>, props: any) => ReactNode | JSX.Element;
declare const createRow: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>, originalRow?: TData | undefined) => MRT_Row<TData>;
declare const extraIndexRangeExtractor: (range: Range, draggingIndex?: number) => number[];
declare function createMRTColumnHelper<TData extends MRT_RowData>(): MRT_ColumnHelper<TData>;
declare const getValueAndLabel: (option: {
    label?: string;
    text?: string;
    value: string;
} | string) => {
    label: string;
    value: string;
};

interface Props$w<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
    columnVirtualizer?: MRT_ColumnVirtualizer;
}
declare const MRT_TableFooter: <TData extends MRT_RowData>({ table, columnVirtualizer, }: Props$w<TData>) => react_jsx_runtime.JSX.Element;

interface Props$v<TData extends MRT_RowData> {
    footer: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableFooterCell: <TData extends MRT_RowData>({ footer, table, }: Props$v<TData>) => react_jsx_runtime.JSX.Element;

interface Props$u<TData extends MRT_RowData> {
    footerGroup: MRT_HeaderGroup<TData>;
    table: MRT_TableInstance<TData>;
    columnVirtualizer?: MRT_ColumnVirtualizer;
}
declare const MRT_TableFooterRow: <TData extends MRT_RowData>({ footerGroup, table, columnVirtualizer, }: Props$u<TData>) => react_jsx_runtime.JSX.Element | null;

interface Props$t<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
    columnVirtualizer?: MRT_ColumnVirtualizer;
}
declare const MRT_TableHead: <TData extends MRT_RowData>({ table, columnVirtualizer, }: Props$t<TData>) => react_jsx_runtime.JSX.Element;

interface Props$s<TData extends MRT_RowData> {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCell: <TData extends MRT_RowData>({ header, table, }: Props$s<TData>) => react_jsx_runtime.JSX.Element;

interface Props$r<TData extends MRT_RowData> {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCellFilterContainer: <TData extends MRT_RowData>({ header, table, }: Props$r<TData>) => react_jsx_runtime.JSX.Element;

interface Props$q<TData extends MRT_RowData> {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCellFilterLabel: <TData extends MRT_RowData>({ header, table, }: Props$q<TData>) => react_jsx_runtime.JSX.Element;

interface Props$p<TData extends MRT_RowData, TValue = MRT_CellValue> {
    column: MRT_Column<TData, TValue>;
    table: MRT_TableInstance<TData>;
    tableHeadCellRef: RefObject<HTMLTableCellElement>;
}
declare const MRT_TableHeadCellGrabHandle: <TData extends MRT_RowData>({ column, table, tableHeadCellRef, }: Props$p<TData, unknown>) => react_jsx_runtime.JSX.Element;

interface Props$o<TData extends MRT_RowData> {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCellResizeHandle: <TData extends MRT_RowData>({ header, table, }: Props$o<TData>) => react_jsx_runtime.JSX.Element;

interface Props$n<TData extends MRT_RowData> {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableHeadCellSortLabel: <TData extends MRT_RowData>({ header, table: { getState, options: { icons: { IconSortDescending, IconSortAscending, IconArrowsSort }, localization, }, }, }: Props$n<TData>) => react_jsx_runtime.JSX.Element;

interface Props$m<TData extends MRT_RowData> {
    headerGroup: MRT_HeaderGroup<TData>;
    table: MRT_TableInstance<TData>;
    columnVirtualizer?: MRT_ColumnVirtualizer;
}
declare const MRT_TableHeadRow: <TData extends MRT_RowData>({ headerGroup, table, columnVirtualizer, }: Props$m<TData>) => react_jsx_runtime.JSX.Element;

declare const useMRT_ColumnVirtualizer: <TData extends MRT_RowData, TScrollElement extends Element | Window = HTMLDivElement, TItemElement extends Element = HTMLTableCellElement>(table: MRT_TableInstance<TData>) => MRT_ColumnVirtualizer | undefined;

interface Params<TData extends MRT_RowData> {
    columnOrder: MRT_ColumnOrderState;
    creatingRow: MRT_Row<TData> | null;
    grouping: MRT_GroupingState;
    tableOptions: MRT_DefinedTableOptions<TData>;
}
declare const useMRT_DisplayColumns: <TData extends MRT_RowData>(params: Params<TData>) => MRT_ColumnDef<TData>[];

declare const useMRT_Effects: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>) => void;

declare const useMRT_RowVirtualizer: <TData extends MRT_RowData, TScrollElement extends Element | Window = HTMLDivElement, TItemElement extends Element = HTMLTableRowElement>(table: MRT_TableInstance<TData>, rows?: MRT_Row<TData>[] | undefined) => MRT_RowVirtualizer<TScrollElement, TItemElement> | undefined;

declare const useMRT_Rows: <TData extends MRT_RowData>(table: MRT_TableInstance<TData>, pinnedRowIds?: string[]) => MRT_Row<TData>[];

declare const useMRT_TableInstance: <TData extends MRT_RowData>(tableOptions: MRT_DefinedTableOptions<TData>) => MRT_TableInstance<TData>;

declare const useMRT_TableOptions: <TData extends MRT_RowData>(tableOptions: MRT_TableOptions<TData>) => MRT_DefinedTableOptions<TData>;

interface Props$l<TData extends MRT_RowData, TValue = MRT_CellValue> {
    cell: MRT_Cell<TData, TValue>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_EditCellTextInput: <TData extends MRT_RowData>({ cell, table, }: Props$l<TData, unknown>) => string | number | boolean | Iterable<react.ReactNode> | react_jsx_runtime.JSX.Element | null | undefined;

interface Props$k<TData extends MRT_RowData, TValue = MRT_CellValue> {
    column: MRT_Column<TData, TValue>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterCheckbox: <TData extends MRT_RowData>({ column, table, }: Props$k<TData, unknown>) => react_jsx_runtime.JSX.Element;

interface Props$j<TData extends MRT_RowData> {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterRangeFields: <TData extends MRT_RowData>({ header, table, }: Props$j<TData>) => react_jsx_runtime.JSX.Element;

interface Props$i<TData extends MRT_RowData> {
    header: MRT_Header<TData>;
    rangeFilterIndex?: number;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterTextInput: <TData extends MRT_RowData>({ header, rangeFilterIndex, table, }: Props$i<TData>) => react_jsx_runtime.JSX.Element;

interface Props$h<TData extends MRT_RowData> extends TextInputProps {
    table: MRT_TableInstance<TData>;
}
declare const MRT_GlobalFilterTextInput: <TData extends MRT_RowData>({ table, ...rest }: Props$h<TData>) => react_jsx_runtime.JSX.Element;

interface Props$g<TData extends MRT_RowData> {
    row?: MRT_Row<TData>;
    selectAll?: boolean;
    staticRowIndex?: number;
    table: MRT_TableInstance<TData>;
}
declare const MRT_SelectCheckbox: <TData extends MRT_RowData>({ row, selectAll, table, staticRowIndex, }: Props$g<TData>) => react_jsx_runtime.JSX.Element;

interface Props$f<TData extends MRT_RowData> {
    header: MRT_Header<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ColumnActionMenu: <TData extends MRT_RowData>({ header, table, }: Props$f<TData>) => react_jsx_runtime.JSX.Element;

declare const mrtFilterOptions: (localization: MRT_Localization) => MRT_InternalFilterOption[];
interface Props$e<TData extends MRT_RowData> {
    header?: MRT_Header<TData>;
    onSelect?: () => void;
    table: MRT_TableInstance<TData>;
}
declare const MRT_FilterOptionMenu: <TData extends MRT_RowData>({ header, onSelect, table, }: Props$e<TData>) => react_jsx_runtime.JSX.Element;

interface Props$d<TData extends MRT_RowData> {
    handleEdit: (event: MouseEvent) => void;
    row: MRT_Row<TData>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_RowActionMenu: <TData extends MRT_RowData>({ handleEdit, row, table, }: Props$d<TData>) => react_jsx_runtime.JSX.Element;

interface Props$c<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ShowHideColumnsMenu: <TData extends MRT_RowData>({ table, }: Props$c<TData>) => react_jsx_runtime.JSX.Element;

interface Props$b<TData extends MRT_RowData, TValue = MRT_CellValue> {
    allColumns: MRT_Column<TData>[];
    column: MRT_Column<TData, TValue>;
    hoveredColumn: MRT_Column<TData> | null;
    setHoveredColumn: Dispatch<SetStateAction<MRT_Column<TData> | null>>;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ShowHideColumnsMenuItems: <TData extends MRT_RowData>({ allColumns, hoveredColumn, setHoveredColumn, column, table, }: Props$b<TData, unknown>) => react_jsx_runtime.JSX.Element | null;

interface Props$a<TData extends MRT_RowData> {
    open: boolean;
    table: MRT_TableInstance<TData>;
}
declare const MRT_EditRowModal: <TData extends MRT_RowData>({ open, table, }: Props$a<TData>) => react_jsx_runtime.JSX.Element;

interface Props$9<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_Table: <TData extends MRT_RowData>({ table, }: Props$9<TData>) => react_jsx_runtime.JSX.Element;

interface Props$8<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_TableContainer: <TData extends MRT_RowData>({ table, }: Props$8<TData>) => react_jsx_runtime.JSX.Element;

interface Props$7<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_TablePaper: <TData extends MRT_RowData>({ table, }: Props$7<TData>) => react_jsx_runtime.JSX.Element;

interface Props$6<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_BottomToolbar: <TData extends MRT_RowData>({ table, }: Props$6<TData>) => react_jsx_runtime.JSX.Element;

interface Props$5<TData extends MRT_RowData> {
    isTopToolbar: boolean;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ProgressBar: <TData extends MRT_RowData>({ isTopToolbar, table, }: Props$5<TData>) => react_jsx_runtime.JSX.Element;

interface Props$4<TData extends MRT_RowData> {
    position?: 'top' | 'bottom';
    table: MRT_TableInstance<TData>;
}
declare const MRT_TablePagination: <TData extends MRT_RowData>({ table, position, }: Props$4<TData>) => react_jsx_runtime.JSX.Element;

interface Props$3<TData extends MRT_RowData> {
    stackAlertBanner?: boolean;
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToolbarAlertBanner: <TData extends MRT_RowData>({ stackAlertBanner, table, }: Props$3<TData>) => react_jsx_runtime.JSX.Element;

interface Props$2<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToolbarDropZone: <TData extends MRT_RowData>({ table, }: Props$2<TData>) => react_jsx_runtime.JSX.Element;

interface Props$1<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_ToolbarInternalButtons: <TData extends MRT_RowData>({ table, }: Props$1<TData>) => react_jsx_runtime.JSX.Element;

interface Props<TData extends MRT_RowData> {
    table: MRT_TableInstance<TData>;
}
declare const MRT_TopToolbar: <TData extends MRT_RowData>({ table, }: Props<TData>) => react_jsx_runtime.JSX.Element;

declare const useMantineReactTable: <TData extends MRT_RowData>(tableOptions: MRT_TableOptions<TData>) => MRT_TableInstance<TData>;

export { type ColumnAlignment, type HTMLPropsRef, type LiteralUnion, type MRT_AggregationFn, MRT_AggregationFns, type MRT_AggregationOption, MRT_BottomToolbar, type MRT_Cell, type MRT_CellValue, type MRT_Column, MRT_ColumnActionMenu, type MRT_ColumnDef, type MRT_ColumnFilterFnsState, type MRT_ColumnFiltersState, type MRT_ColumnHelper, type MRT_ColumnOrderState, MRT_ColumnPinningButtons, type MRT_ColumnPinningState, type MRT_ColumnSizingInfoState, type MRT_ColumnSizingState, type MRT_ColumnVirtualizer, MRT_CopyButton, type MRT_CreateTableFeature, MRT_DefaultColumn, MRT_DefaultDisplayColumn, type MRT_DefinedColumnDef, type MRT_DefinedTableOptions, type MRT_DensityState, type MRT_DisplayColumnDef, type MRT_DisplayColumnIds, MRT_EditActionButtons, MRT_EditCellTextInput, MRT_EditRowModal, MRT_ExpandAllButton, MRT_ExpandButton, type MRT_ExpandedState, MRT_FilterCheckbox, type MRT_FilterFn, MRT_FilterFns, type MRT_FilterOption, MRT_FilterOptionMenu, MRT_FilterRangeFields, MRT_FilterTextInput, MRT_GlobalFilterTextInput, MRT_GrabHandleButton, type MRT_GroupColumnDef, type MRT_GroupingState, type MRT_Header, type MRT_HeaderGroup, type MRT_Icons, type MRT_InternalFilterOption, type MRT_Localization, type MRT_PaginationProps, type MRT_PaginationState, MRT_ProgressBar, type MRT_Row, MRT_RowActionMenu, type MRT_RowData, type MRT_RowModel, type MRT_RowSelectionState, type MRT_RowVirtualizer, MRT_SelectCheckbox, MRT_ShowHideColumnsButton, MRT_ShowHideColumnsMenu, MRT_ShowHideColumnsMenuItems, type MRT_SortingFn, MRT_SortingFns, type MRT_SortingOption, type MRT_SortingState, MRT_Table, MRT_TableBody, MRT_TableBodyCell, MRT_TableBodyCellValue, MRT_TableBodyRow, MRT_TableBodyRowGrabHandle, MRT_TableContainer, MRT_TableDetailPanel, MRT_TableFooter, MRT_TableFooterCell, MRT_TableFooterRow, MRT_TableHead, MRT_TableHeadCell, MRT_TableHeadCellFilterContainer, MRT_TableHeadCellFilterLabel, MRT_TableHeadCellGrabHandle, MRT_TableHeadCellResizeHandle, MRT_TableHeadCellSortLabel, MRT_TableHeadRow, type MRT_TableInstance, type MRT_TableOptions, MRT_TablePagination, MRT_TablePaper, type MRT_TableState, MRT_ToggleDensePaddingButton, MRT_ToggleFiltersButton, MRT_ToggleFullScreenButton, MRT_ToggleGlobalFilterButton, MRT_ToggleRowActionMenuButton, MRT_ToolbarAlertBanner, MRT_ToolbarDropZone, MRT_ToolbarInternalButtons, MRT_TopToolbar, type MRT_Updater, type MRT_VirtualItem, type MRT_VirtualizerOptions, type MRT_VisibilityState, MantineReactTable, type MantineShade, Memo_MRT_TableBody, Memo_MRT_TableBodyCell, Memo_MRT_TableBodyRow, type Prettify, type Xor, createMRTColumnHelper, createRow, extraIndexRangeExtractor, flexRender, getAllLeafColumnDefs, getCanRankRows, getColumnId, getDefaultColumnFilterFn, getDefaultColumnOrderIds, getIsFirstColumn, getIsFirstRightPinnedColumn, getIsLastColumn, getIsLastLeftPinnedColumn, getLeadingDisplayColumnIds, getPrimaryColor, getPrimaryShade, getTotalRight, getTrailingDisplayColumnIds, getValueAndLabel, localizedFilterOption, mrtFilterOptions, parseCSSVarId, parseFromValuesOrFunc, prepareColumns, rankGlobalFuzzy, reorderColumn, showExpandColumn, useMRT_ColumnVirtualizer, useMRT_DisplayColumns, useMRT_Effects, useMRT_RowVirtualizer, useMRT_Rows, useMRT_TableInstance, useMRT_TableOptions, useMantineReactTable };
