import React, { useState, useLayoutEffect, useMemo, useEffect } from 'react';
import { useDebounceResize } from '../dimensions/useDebounceResize';
import { getColumns, getRowHeights, getRow } from './tools';

const defaultHeights = {
    children: {},
    main: [],
    columns: 0
};

// when we get the height of each row, we need to know on wat row is each item in order to know its desired height
const inflateItemHeights = (rowHeights, columns, nItems) => {
    const heights = [];
    for (let i = 0; i < nItems; i += 1) {
        const rowIndex = getRow(i, columns);
        heights[i] = rowHeights[rowIndex];
    }
    return heights;
};

/**
 * custom hook that calculates element heights among the sibling elements on the same row in a layout
 * so that an element has information about the highest height of its sibilngs, and of some of their children, and
 * that it is then possible to vertically align elements and their contents in a row
 * @param {number} nItems the number of items in the whole layout
 * @param {array} childrenRefNames strings of the refs names we need to also calculate among children of the items
 */
export const useRowHeights = (nItems, childrenRefNames = null, showCode) => {
    const { mainRefs, childrenRefs } = useMemo(() => {
        const refs = { childrenRefs: {}, mainRefs: [] };
        for (let index = 0; index < nItems; index += 1) {
            refs.mainRefs[index] = React.createRef();
            if (childrenRefNames) {
                childrenRefNames.forEach(name => {
                    refs.childrenRefs[name] = refs.childrenRefs[name] || [];
                    refs.childrenRefs[name][index] = React.createRef();
                });
            }
        }
        return refs;
    }, [nItems, childrenRefNames]);

    const [heights, setHeights] = useState(defaultHeights);
    const [isInitialRender, setIsInitialRender] = useState(true);
    const calculateHeights = () => {
        const columns = getColumns(mainRefs);
        // pointless to do all the calculations if we have one element per row
        if (columns <= 1) { return; }

        // first render, compute children only, as the result will trigger a rerender that'll influence item heights
        if (heights.columns !== columns) {
            const childrenHeights = {};
            if (childrenRefNames) {
                childrenRefNames.forEach(name => {
                    childrenHeights[name] = inflateItemHeights(
                        getRowHeights(childrenRefs[name], columns),
                        columns,
                        nItems
                    );
                });
            }
            setHeights({
                ...defaultHeights,
                columns,
                children: childrenHeights
            });
        } else if (!heights.main.length) {
            const mainRowHeights = inflateItemHeights(
                getRowHeights(mainRefs, columns),
                columns,
                nItems
            );
            setHeights({
                ...heights,
                main: mainRowHeights
            });
        }
    };

    useEffect(() => {
        setHeights(defaultHeights);
        calculateHeights();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [showCode]);

    useLayoutEffect(() => {
        // Do initial calculation immediately
        calculateHeights();

        // If it's the initial render, wait for fonts and recalculate
        if (isInitialRender && document.fonts?.ready) {
            document.fonts.ready.then(() => {
                setHeights(defaultHeights); // Reset heights to trigger recalculation
                setIsInitialRender(false);
                calculateHeights();
            });
        }
    });

    useDebounceResize(() => {
        setHeights(defaultHeights);
        setIsInitialRender(true);
    });

    return [mainRefs, childrenRefs, heights];
};
