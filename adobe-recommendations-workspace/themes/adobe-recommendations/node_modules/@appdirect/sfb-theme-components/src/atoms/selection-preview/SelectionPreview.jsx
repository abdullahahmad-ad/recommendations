import React, { useState } from 'react';
import PropTypes from 'prop-types';
import { useBodyFixed } from '../../tools/useBodyFixed';
import SelectedAddon from '../selected-addon/SelectedAddon';
import SelectedEdition from '../selected-edition/SelectedEdition';
import UpgradeModal from '../../components/upgrade-modal/UpgradeModal';
import Button from '../button/Button';
import EditionButtonIcon from '../edition-button-icon/EditionButtonIcon';
import Icon from '../icon/Icon';
import { createNamespace } from '../../tools/namingTools';
import { CTA_BUY, CTA_BUY_MORE, CTA_ADD_TO_CART, CTA_MANAGE_APP, CTA_UPDATE_CART_ITEM, CTA_CANCEL, CART_URL, CTA_UPGRADE } from '../../constants/actions';
import { handleBuyAction, handleUpdateAction, handleAddToCartAction,
    handleUpdateAddonsNonStackable, handleFollowUrlAction } from '../../tools/callToActions';
import { callToActionListShape } from '../../constants/prop-types/application/call-to-actions';
import { configuratorPropTypes, selectedEditionPropTypes } from '../../constants/prop-types/application/configurator';
// IMPORTANT: (s)css should be imported after other atoms/components
import './styles/SelectionPreview.scss';

const n = createNamespace('SelectionPreview');

export const SelectionPreviewComponent = ({
    data: {
        configurator,
        selectedEdition,
        selectedAddons,
        callToActions,
        productImgSrc,
        productImageAlt,
        isAddedToCart,
        user,
        i18nCart,
        referUrl
    },
    isCondensed,
    isFullscreen,
    showPricing,
    onCollapseAddons
}) => {
    const {
        isNonStackableWithAddonsAppInCart,
        cartId,
        editionInCartItemId,
        productId,
        crossSellManagementEnabled,
        isNonStackable,
        hasAddons
    } = configurator;

    const i18n = {
        ...SelectionPreviewComponent.defaultProps.data.configurator.i18n,
        ...configurator.i18n,
        cart: i18nCart
    };
    const buyActions = callToActions ? callToActions.items : [];
    const defaultAddonsLimit = 1;
    const fullscreenModifier = isFullscreen && 'fullscreen';
    const condensedModifier = isCondensed && 'condensed';
    const [isAddonsCollapsed, setAddonsCollapseState] = useState(true);
    const [addonsLimit, setAddonsLimit] = useState(defaultAddonsLimit);
    const [upgradeDetails, setUpgradeDetails] = useState(null);

    // If fullscreen add fixed position to body
    useBodyFixed(isFullscreen, true);

    if (!selectedEdition) {
        return '';
    }

    const handleCollapse = () => {
        const newLimit = isAddonsCollapsed ? selectedAddons.length : defaultAddonsLimit;

        setAddonsLimit(newLimit);
        setAddonsCollapseState(!isAddonsCollapsed);
        onCollapseAddons(isAddonsCollapsed);
    };

    const handleUpgradeAction = action => {
        setUpgradeDetails(action.popup);
    };

    const handleActionTypes = item => {
        let buttonStyle;
        let icon;

        switch (item.actionType) {
            case CTA_MANAGE_APP:
                buttonStyle = 'emphasisAlt';
                break;
            case CTA_ADD_TO_CART:
                buttonStyle = 'emphasisAlt';
                icon = 'cart';
                break;
            case CTA_BUY:
            case CTA_BUY_MORE:
                buttonStyle = 'emphasis';
                break;
            case CTA_UPDATE_CART_ITEM:
                buttonStyle = 'primary';
                break;
            default:
                buttonStyle = item.isPrimary ? 'primary' : 'secondary';
        }
        return { buttonStyle, icon };
    };

    const handleClick = action => {
        const { actionType, urlCreator } = action;

        switch (actionType) {
            case CTA_MANAGE_APP:
            case CTA_CANCEL:
                return handleFollowUrlAction(action);
            case CTA_ADD_TO_CART:

                if (isNonStackableWithAddonsAppInCart) {
                    return handleUpdateAddonsNonStackable(
                        cartId,
                        editionInCartItemId,
                        selectedEdition?.plans?.[0]?.uuid,
                        selectedAddons?.map(addon => addon?.edition?.[0]?.plans?.[0]?.uuid),
                        user?.userUuid,
                        user?.companyUuid
                    );
                }

                return handleAddToCartAction(
                    selectedEdition,
                    selectedAddons,
                    productId,
                    crossSellManagementEnabled,
                    isNonStackable,
                    hasAddons,
                    urlCreator
                );
            case CTA_UPGRADE:
                return handleUpgradeAction(action);
            case CTA_UPDATE_CART_ITEM:
                return handleUpdateAction(
                    action,
                    selectedEdition,
                    selectedAddons,
                    configurator.productId,
                    configurator.crossSellManagementEnabled,
                    configurator.editionInCartItemId
                );
            case CTA_BUY:
            case CTA_BUY_MORE:
            default:
                return handleBuyAction(
                    action,
                    selectedEdition,
                    selectedAddons,
                    configurator?.productId,
                    configurator?.crossSellManagementEnabled
                );
        }
    };

    const renderActionButtons = action => {
        const dataId = action.actionType.toLowerCase();
        const actionTypeData = handleActionTypes(action);
        const buttonModifiers = [actionTypeData.icon && 'with-icon', fullscreenModifier];

        // if there is an UPDATE_CART_ITEM action, it means that we also need
        // a CANCEL button which is not defined in calltoactions
        const hasCancelButton = action.actionType === CTA_UPDATE_CART_ITEM;

        const cancelButton = hasCancelButton ? (
            <div {...n('button').props} key="cancel-action">
                <Button
                    wide={!isFullscreen}
                    onClick={() => handleClick({
                        url: CART_URL,
                        actionType: CTA_CANCEL
                    })}
                    ctaType={CTA_CANCEL}
                >
                    {i18n.cancel}
                </Button>
            </div>
        ) : null;

        return (
            <React.Fragment key={action.actionType}>
                <div {...n('button', buttonModifiers).withTestId('actions-container').withE2EId('actions-container').props} key="main-action">
                    {
                        action?.actionType === CTA_ADD_TO_CART && configurator?.isInCart && isAddedToCart
                            ? (
                                <EditionButtonIcon
                                    data-testid="button:added-to-cart:edition"
                                    theme="emphasisAlt-outline"
                                    type="button"
                                    icon="check"
                                    notClickable
                                    iconClass="addedToCart"
                                >
                                    {i18n.cart.addedToCart}
                                </EditionButtonIcon>
                            )
                            : (
                                <Button
                                    data-testid={`button:${dataId}:product`}
                                    type={actionTypeData.buttonStyle}
                                    wide={!isFullscreen}
                                    className={dataId && `btn-${dataId}`}
                                    onClick={() => handleClick(action)}
                                    ctaType={action.actionType}
                                >
                                    {actionTypeData.icon && <Icon type="cart" {...n('buttonIcon').props} />}
                                    {action.label}
                                </Button>
                            )
                    }
                </div>
                {cancelButton}
            </React.Fragment>

        );
    };

    const renderCollapseAddonsButton = () => {
        const label = isAddonsCollapsed ? `+ ${selectedAddons.length - addonsLimit} ${i18n.more}` : i18n.showLess;

        return (
            <div {...n('btnCollapse').props}>
                <Button
                    buttonType="link"
                    data-testid="button:collapse:addons"
                    type="primary"
                    onClick={() => handleCollapse()}
                >
                    {label}
                </Button>
            </div>
        );
    };

    const renderAddons = () => {
        if (!selectedAddons || !selectedAddons.length) {
            return null;
        }
        return (
            <div {...n('previewList', condensedModifier).props}>
                <h2 {...n('previewTitle', isCondensed && 'hidden').withTestId().props}>{i18n.selectedAddons}</h2>
                {(isAddonsCollapsed ? selectedAddons.slice(0, addonsLimit) : selectedAddons).map(selectedAddon => (
                    <div {...n('previewItem', ['addon', condensedModifier]).withTestId('previewAddonItem').props} key={`selectedAddon-${selectedAddon.name}`}>
                        <SelectedAddon
                            data={selectedAddon}
                            showDescription={!isFullscreen && !isCondensed}
                            showPricing={!isFullscreen && !isCondensed && showPricing}
                        />
                    </div>
                ))}
                {!isFullscreen && selectedAddons.length > defaultAddonsLimit && renderCollapseAddonsButton()}
            </div>
        );
    };

    const renderModal = () => {
        const handleClose = () => {
            setUpgradeDetails(null);
        };

        return (
            upgradeDetails && <UpgradeModal upgrades={upgradeDetails} handleClose={handleClose} />
        );
    };

    const contentModifiers = [condensedModifier, fullscreenModifier];

    return (
        <section {...n('wrapper', contentModifiers).withE2EId().props} id="selectionPreview">
            <div {...n('content', contentModifiers).props}>
                <h2 {...n('previewTitle', isCondensed && 'hidden').withTestId().props}>{i18n.selectedEdition}</h2>
                <div {...n('previewWrapper', contentModifiers).props}>
                    {isFullscreen && (
                        <>
                            <div {...n('fullscreenTitle').props}>{i18n.selectedProduct}</div>
                            <div {...n('closeFullscreen').props}>
                                <Button buttonType="icon" onClick={() => handleCollapse()}>
                                    <Icon type="close" width="12px" fill="#fff" {...n('closeFullscreenIcon').props} />
                                    <span {...n('closeFullscreenLabel').props}>{i18n.closeFullscreen}</span>
                                </Button>
                            </div>
                        </>
                    )}
                    <div {...n('previewContent', contentModifiers).props}>
                        <div {...n('previewItem', 'edition').withTestId('previewEditionItem').props}>
                            <SelectedEdition
                                isCondensed={isCondensed}
                                selectedEdition={selectedEdition}
                                i18n={i18n}
                                productImgSrc={productImgSrc}
                                productImageAlt={productImageAlt}
                                showDescription={!isFullscreen && !isCondensed}
                                showPricing={!isFullscreen}
                                referUrl={referUrl}
                            />
                        </div>
                        {renderAddons()}
                    </div>
                    {buyActions && buyActions.length ? (
                        <div {...n('buttons', contentModifiers).props}>
                            {buyActions.map(renderActionButtons)}
                        </div>
                    ) : ''}

                    {renderModal()}
                </div>
            </div>
        </section>
    );
};

const defaultSelectionPreviewProps = {
    data: PropTypes.shape({
        configurator: configuratorPropTypes,
        selectedEdition: selectedEditionPropTypes,
        referUrl: PropTypes.string,
        selectedAddons: PropTypes.arrayOf(
            PropTypes.shape({
                name: PropTypes.string,
                edition: PropTypes.arrayOf(
                    PropTypes.shape({
                        costs: PropTypes.shape({
                            unitPrice: PropTypes.arrayOf(
                                PropTypes.shape({
                                    usageRange: PropTypes.arrayOf(
                                        PropTypes.shape({
                                            formattedFullPriceElements: PropTypes.array
                                        })
                                    )
                                })
                            )
                        })
                    })
                )
            })
        ),
        callToActions: callToActionListShape,
        productImgSrc: PropTypes.string,
        productImageAlt: PropTypes.string,
        isAddedToCart: PropTypes.bool,
        user: PropTypes.object,
        i18nCart: PropTypes.object
    }),
    isCondensed: PropTypes.bool,
    isFullscreen: PropTypes.bool,
    showPricing: PropTypes.bool,
    onCollapseAddons: PropTypes.func
};

SelectionPreviewComponent.propTypes = defaultSelectionPreviewProps;

SelectionPreviewComponent.defaultProps = {
    data: {
        configurator: {
            crossSellManagementEnabled: false,
            i18n: {
                selectedEdition: 'Selected Edition',
                selectedAddons: 'Selected Addons',
                selectedProduct: 'Selected Product',
                startingAt: 'Starting at',
                showLess: 'Show Less',
                more: 'more',
                cancel: 'Cancel',
                closeFullscreen: 'Close fullscreen'
            },
            editionInCartItemId: ''
        },
        selectedEdition: {
            name: 'Default Edition',
            plans: [
                {
                    costs: {
                        unitPrice: [
                            {
                                usageRange: [
                                    {
                                        formattedFullPriceElements: []
                                    }
                                ]
                            }
                        ]
                    }
                }
            ]
        },
        referUrl: '',
        selectedAddons: [],
        callToActions: {
            items: [
                {
                    label: 'Buy',
                    tooltip: '',
                    isPrimary: true,
                    enabled: true,
                    url: '',
                    actionType: ''
                }
            ]
        },
        productImgSrc: null,
        productImageAlt: '',
        isAddedToCart: false,
        user: {
            isLoggedIn: false
        },
        i18nCart: {
            addedToCart: 'Added to Cart'
        }
    },
    onCollapseAddons: () => { },
    isCondensed: false,
    isFullscreen: false,
    showPricing: true
};

export default SelectionPreviewComponent;
