import React, { useCallback, useMemo, useRef, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import Slick from 'react-slick';

import { bMedium } from '../../constants/breakpoints';
import { productSliderSchema,
    productSliderSettingsShape,
    productSliderDefaultSettings,
    IS_DESCRIPTION_VISIBLE,
    IS_RATINGS_VISIBLE,
    IS_BADGES_VISIBLE,
    IS_RIBBONS_VISIBLE,
    IS_VENDOR_VISIBLE } from '../../constants/components/schemas/product-slider';
import { NUMBER_OF_DEFAULT_SLIDES, MANUALLY_CURATED_CONTENT_TYPE, DYNAMICALLY_CURATED_CONTENT_TYPE } from '../../constants/components/slider';
import { tileShape } from '../../constants/components/prop-types/tile';
import { getReponsiveSettings } from '../../tools/responsive/slider';
import { generateUniqueID } from '../../tools/helpers';
import { createNamespace } from '../../tools/namingTools';
import { useContainerWidth } from '../../tools/widths/useContainerWidth';
import { getAbsoluteCoordinates } from '../../tools/coordinates';
import { defaultSlider } from '../../tools/defaultSlider';
import { isSlideInsideActiveRange, isSlideInsideInitialRange } from '../../tools/components/slider';
import ProductQuickView from '../product-quick-view/ProductQuickView';
import Button from '../button/Button';
import Icon from '../icon/Icon';
import Modal from '../modal/Modal';
import Slide from './atoms/Slide';
// IMPORTANT: (s)css should be imported after other atoms/components
import './styles/Slider.scss';

const n = createNamespace('Slider');

const renderSeeMoreButton = (contentType, buttonLabel, url) => (
    contentType !== MANUALLY_CURATED_CONTENT_TYPE && buttonLabel && url
);

const SliderComponent = ({
    name,
    url,
    items: propItems,
    staticTitle,
    // although component's main purpose is being a slider, it can also show a static list of elements
    isSlider: isSliderSetting,
    maxRows,
    buttonLabel,
    contentType,
    i18n,
    settings,
    serviceFailure
}) => {
    const [currentQuickview, setCurrentQuickview] = useState(null);

    // track current slide to update a11y tabIndex
    const [currentSlide, setCurrentSlide] = useState(0);

    const onSlideChange = newCurrentSlide => {
        // change of state is necessary on each change,
        // to trigger the layout effect that will check for slide's a11y tabindex
        // see useCarouselA11yVisible
        setCurrentSlide(newCurrentSlide);
    };

    const i18nWithDefaults = useMemo(
        () => {
            if (!i18n) {
                return SliderComponent.defaultProps.i18n;
            }
            return { ...SliderComponent.defaultProps.i18n, ...i18n };
        },
        [i18n]
    );

    const componentSettings = {
        ...SliderComponent.defaultProps.settings,
        ...settings
    };

    const {
        sliderTitle,
        layout,
        borderRadius,
        cardBorderRadius,
        size,
        tileBackgroundColor,
        textBackgroundColor,
        isShadowVisible,
        tileCtaLabel,
        displayOptions,
        hasQuickview,
        quickviewViewMode
    } = componentSettings;

    // if props items are empty, fill with placeholder slides
    const items = useMemo(() => {
        if (!propItems || !propItems.length) {
            let defaultSlideTexts;
            if (serviceFailure) {
                defaultSlideTexts = {
                    title: i18nWithDefaults.serviceFailure.listing.title,
                    description: i18nWithDefaults.serviceFailure.listing.description
                };
            } else {
                defaultSlideTexts = {
                    title: i18nWithDefaults.defaultTitlePlaceholder,
                    description: i18nWithDefaults.defaultDescriptionPlaceholder,
                    price: i18nWithDefaults.defaultPricePlaceholder
                };
            }
            return Array.from(
                Array(NUMBER_OF_DEFAULT_SLIDES).keys()
            ).map(
                index => defaultSlider(index, defaultSlideTexts)
            );
        }
        return propItems;
    }, [propItems, i18nWithDefaults]);

    const nItems = items && items.length;

    const sliderRef = useRef(null);
    const sliderWrapperRef = useRef(null);

    const isDescriptionVisible = displayOptions ? displayOptions.includes(IS_DESCRIPTION_VISIBLE) : false;
    const isRatingsVisible = displayOptions ? displayOptions.includes(IS_RATINGS_VISIBLE) : false;
    const isVendorVisible = displayOptions ? displayOptions.includes(IS_VENDOR_VISIBLE) : false;
    const isRibbonsVisible = displayOptions ? displayOptions.includes(IS_RIBBONS_VISIBLE) : false;
    const isBadgesVisible = displayOptions ? displayOptions.includes(IS_BADGES_VISIBLE) : false;

    const [containerRef, containerWidth] = useContainerWidth();
    const isMobile = Boolean(containerWidth && containerWidth < bMedium);

    const sliderResponsiveSettings = useMemo(() => getReponsiveSettings(layout, size, nItems, containerWidth), [
        layout,
        size,
        nItems,
        containerWidth
    ]);

    const slidesToShow = sliderResponsiveSettings.columns;

    // no slider on mobile, slides are displayed one over the other
    const isSlider = isSliderSetting && !isMobile && nItems > slidesToShow;
    const staticModifier = isSlider ? 'slider' : 'static';
    const listModifiers = [staticModifier, isMobile && 'mobile'];

    useEffect(() => {
        const updateQuickview = e => {
            const { targetSlider, id, left, top } = e.detail;
            const isTargetedSlider = sliderRef === targetSlider;

            if (isTargetedSlider) {
                setCurrentQuickview({ id, left, top });
            } else {
                setCurrentQuickview(null);
            }
        };

        window.addEventListener('updateQuickview', updateQuickview);
        return () => window.removeEventListener('updateQuickview', updateQuickview);
    }, []);

    const { columns = 1 } = sliderResponsiveSettings || {};

    const componentVariables = useMemo(() => {
        const variables = { 'slider-column': columns };

        if (borderRadius) {
            variables['slide-border-radius'] = `${borderRadius}px`;
        }

        return variables;
    }, [columns, borderRadius]);

    const previousSlide = () => {
        setCurrentQuickview(null);
        sliderRef.current.slickPrev();
    };

    const nextSlide = () => {
        setCurrentQuickview(null);
        sliderRef.current.slickNext();
    };

    // will horizontally center on clicked button, and adjust top to slider's top
    const getQuickviewTargetPosition = event => {
        const { left } = getAbsoluteCoordinates(event.currentTarget);
        const { top } = getAbsoluteCoordinates(sliderWrapperRef.current);
        return {
            top,
            left
        };
    };

    // dispatch an event, so that if there are more than one slider in the page, only one
    // can have a quickview open at any given time
    const openQuickView = (event, id) => {
        const { left, top } = getQuickviewTargetPosition(event);

        const quickViewPayload = {
            targetSlider: sliderRef,
            id,
            left,
            top
        };

        const updateQueriesEvent = new CustomEvent('updateQuickview', {
            bubbles: true,
            detail: quickViewPayload
        });
        window.dispatchEvent(updateQueriesEvent);
    };

    const renderHeaderTitle = useCallback(() => {
        const title = sliderTitle || staticTitle || name;

        return title && (<h2 {...n('title').withTestId().withE2EId().props}>{title}</h2>);
    }, [sliderTitle, name, staticTitle]);

    const renderSlide = (item, index) => {
        if (!item || !item.id) {
            return null;
        }
        const tileSettings = {
            layout,
            size,
            borderRadius,
            cardBorderRadius,
            tileBackgroundColor,
            textBackgroundColor,
            isDescriptionVisible,
            isBadgesVisible,
            isRibbonsVisible,
            isVendorVisible,
            isRatingsVisible,
            isShadowVisible
        };

        const insideActiveRange = isSlideInsideActiveRange(currentSlide, index, slidesToShow);
        const insideInitialActiveRange = isSlideInsideInitialRange(index, slidesToShow, maxRows, isSlider);

        // slides that initially show should have the <img> set to high priority to improve LCP
        const imageAttributes = {
            fetchpriority: insideInitialActiveRange ? 'high' : 'low'
        };

        return (
            <Slide
                key={generateUniqueID([item.id, item.name, index])}
                index={index}
                item={item}
                tileSettings={tileSettings}
                columns={slidesToShow}
                isSlider={isSlider}
                isMobile={isMobile}
                layout={layout}
                hasQuickView={hasQuickview}
                onQuickView={openQuickView}
                tileCtaLabel={tileCtaLabel}
                i18n={i18nWithDefaults}
                insideActiveRange={insideActiveRange}
                imageAttributes={imageAttributes}
                serviceFailure={serviceFailure}
            />
        );
    };

    const renderSliderArrows = () => {
        const buttonProps = {
            type: 'white',
            size: 'small',
            condensed: true,
            className: n('navigationButton').props.className
        };

        return (
            <div {...n('arrows').withE2EId().props}>
                <div {...n('arrow', 'previous').withTestId('goPrev').withE2EId('prev').props}>
                    <Button
                        {...buttonProps}
                        onClick={previousSlide}
                    >
                        <Icon type="caretLeft" {...n('arrowIcon').withE2EId('arrowIconPrev').props} />
                        <span {...n('arrowText').withE2EId('arrowTextPrev').props}>Previous</span>
                    </Button>
                </div>
                <div {...n('arrow', 'next').withTestId('goNext').withE2EId('goNext').props}>
                    <Button
                        {...buttonProps}
                        onClick={nextSlide}
                    >
                        <Icon type="caretRight" {...n('arrowIcon').withE2EId('arrowIconNext').props} />
                        <span {...n('arrowText').withE2EId('arrowTextNext').props}>Next</span>
                    </Button>
                </div>
            </div>
        );
    };

    const renderQuickview = () => {
        let quickview = <Modal currentKey="none" />;

        const quickviewItem = currentQuickview ? items.find(app => app.id === currentQuickview.id) : null;

        if (quickviewItem) {
            quickview = (
                <Modal
                    currentKey={currentQuickview.id}
                    left={currentQuickview.left}
                    top={currentQuickview.top}
                    onClose={() => setCurrentQuickview(null)}
                    currentItem={(
                        <ProductQuickView
                            data={{
                                ...quickviewItem,
                                i18n: i18nWithDefaults
                            }}
                            settings={{ quickviewViewMode }}
                        />
                    )}
                />
            );
        }

        return quickview;
    };

    const renderViewMore = (isLink = false) => renderSeeMoreButton(contentType, buttonLabel, url) && (
        <div {...n('viewMore').withTestId().withE2EId().props}>
            <Button
                type="primary"
                buttonType={isLink ? 'link' : 'button'}
                size={!isLink ? 'small' : 'default'}
                className="btn-view-more"
                onClick={() => { window.location = url; }}
            >
                <span {...n('viewMoreText').withClass('button_text').withTestId().withE2EId().props}>{buttonLabel}</span>
                {isLink && <Icon {...n('viewMoreIcon').withTestId().withE2EId().props} type="caretRight" />}
            </Button>
        </div>
    );

    const headerButtons = (url || sliderResponsiveSettings.infinite) && (
        <div {...n('headerButtons').props}>
            {!isMobile && renderViewMore()}
            {sliderResponsiveSettings.infinite && renderSliderArrows()}
        </div>
    );

    const renderableItems = useMemo(() => {
        // on mobile, there is no slider but we display an amount of slides depending on the default
        if (isMobile) {
            return items.slice(0, sliderResponsiveSettings.maxShown);
        }
        // when there is no slider, we display a given number of static rows
        if (!isSliderSetting) {
            return items.slice(0, sliderResponsiveSettings.columns * maxRows);
        }
        return items;
    }, [items, isMobile, isSliderSetting, maxRows, sliderResponsiveSettings]);

    const slides = renderableItems.map(renderSlide);

    const slideContents = isSlider ? (
        <Slick
            ref={sliderRef}
            draggable={false}
            arrows={false}
            speed={500}
            mobileFirst
            slidesToShow={slidesToShow}
            slidesToScroll={slidesToShow}
            infinite={sliderResponsiveSettings.infinite}
            afterChange={onSlideChange}
        >
            {slides}
        </Slick>

    ) : slides;

    return (
        <div {...n('container').withTestId().withVariables(componentVariables).withE2EId().props} ref={containerRef}>
            <div {...n('header').withE2EId().props}>
                {renderHeaderTitle()}
                {isSlider && !!nItems && headerButtons}
            </div>
            <div>
                <div {...n('list', listModifiers).withE2EId().props} ref={sliderWrapperRef}>
                    {slideContents}
                </div>
                {renderQuickview()}
                {isMobile && (
                    <div {...n('footer').withE2EId().props}>{renderViewMore(true)}</div>
                )}
            </div>
        </div>
    );
};

SliderComponent.schema = () => ({
    name: 'Slider',
    form: {
        ...productSliderSchema
    }
});

SliderComponent.propTypes = {
    name: PropTypes.string,
    staticTitle: PropTypes.string,
    url: PropTypes.string,
    isSlider: PropTypes.bool,
    maxRows: PropTypes.number,
    buttonLabel: PropTypes.string,
    contentType: PropTypes.oneOf([MANUALLY_CURATED_CONTENT_TYPE, DYNAMICALLY_CURATED_CONTENT_TYPE]),
    items: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.shape(tileShape)), PropTypes.array]),
    i18n: PropTypes.shape({
        quickview: PropTypes.string,
        defaultTitlePlaceholder: PropTypes.string,
        defaultDescriptionPlaceholder: PropTypes.string,
        defaultPricePlaceholder: PropTypes.string
    }),
    settings: PropTypes.shape(productSliderSettingsShape),
    serviceFailure: PropTypes.bool
};

SliderComponent.defaultProps = {
    items: [],
    name: '',
    url: '',
    staticTitle: undefined,
    isSlider: true,
    maxRows: 1,
    buttonLabel: null,
    contentType: DYNAMICALLY_CURATED_CONTENT_TYPE,
    i18n: {
        quickview: 'Quickview',
        defaultTitlePlaceholder: 'Product Name',
        defaultDescriptionPlaceholder: 'Product description goes here in this space provided.',
        defaultPricePlaceholder: 'From'
    },
    settings: productSliderDefaultSettings,
    serviceFailure: false
};

export default SliderComponent;
