import React, { useState, forwardRef, useRef } from 'react';
import PropTypes from 'prop-types';
import { createNamespace } from '../../../tools/namingTools';
import { stripSlash } from '../../../tools/stringTools';
import { generateUniqueID } from '../../../tools/helpers';
import { parsePricingAction, getButtonTypeForCta, getActionLabel, canReplaceEdition } from '../../../tools/callToActions';
import { parseDiscountOff } from '../../../tools/components/productEditionCard';
import { CTA_ADD_TO_CART } from '../../../constants/actions';
import { useCarouselA11yVisible } from '../../../tools/a11y/useCarouselA11yVisible';
import Badge from '../../badge/Badge';
import Bullet from '../../bullet/Bullet';
import Button from '../../button/Button';
import EditionButtonIcon from '../../edition-button-icon/EditionButtonIcon';
import Icon from '../../icon/Icon';
import Pricing from '../../pricing/Pricing';
// IMPORTANT: (s)css should be imported after other atoms/components
import './styles/ProductEditionCard.scss';

const n = createNamespace('ProductEditionCard');

const pickPriceElements = ({ unit, price, formattedFullPriceElements }) => ({
    unit,
    discount: {
        discountOff: price.formatted.discountOff
    },
    price: {
        original: price.formatted.originalFullPriceElements,
        formatted: formattedFullPriceElements
    }
});

const getPriceLimitLabel = priceUnit => {
    if (!priceUnit) {
        return null;
    }

    const hasOnlyMin = priceUnit.min === 1 && !priceUnit.max;
    const shouldRenderLimitLabel = priceUnit.limitLabel && !hasOnlyMin;

    return shouldRenderLimitLabel ? priceUnit.limitLabel : null;
};

const reducePrices = (flatPrice, unitPrice) => {
    const prices = [];

    // if there is a flat price, that needs to be shown first
    if (flatPrice) {
        prices.push(pickPriceElements(flatPrice));
    }

    // if there are unit prices, they need to be added
    if (unitPrice) {
        unitPrice.forEach(price => {
            price.usageRange.forEach(usageRange => {
                prices.push(pickPriceElements(usageRange));
            });
        });
    }

    return prices;
};

const RenderPlan = ({ plan }) => (
    <li {...n('section').props} key={plan.uuid}>
        {Object.keys(plan.costs).length ? <RenderCosts plan={plan} /> : null}
    </li>
);

const RenderCosts = ({ plan: {
    costs: { flatPrice, unitPrice },
    setupFees,
    contractFees,
    formattedContract,
    uuid
} }) => {
    // unify the prices into one array
    const prices = reducePrices(flatPrice, unitPrice);
    // split off the first element
    const [mainPrice, ...otherPrices] = prices;
    const shouldRenderPrices = !!otherPrices.length || !!setupFees.length || !!contractFees.length;

    return (
        <>
            {mainPrice && (
                <div {...n('mainPrice').props}>
                    <RenderPrice unit={mainPrice.unit} formattedPrice={mainPrice.price.formatted} />
                    {formattedContract && <Badge label={formattedContract} {...n('contract').props} />}
                    {mainPrice.discount.discountOff && (
                        <div {...n('mainPriceDiscount').props}>
                            <RenderDiscount
                                discountOff={mainPrice.discount.discountOff}
                                original={mainPrice.price.original}
                            />
                        </div>
                    )}
                </div>
            )}
            {shouldRenderPrices && (
                <ul {...n('additionalPrice').props}>
                    {Boolean(otherPrices && otherPrices.length) && otherPrices.map(otherPrice => (
                        <li {...n('pricingItem').props} key={generateUniqueID([...otherPrice.price.formatted, uuid])}>
                            <RenderPrice
                                unit={otherPrice.unit}
                                formattedPrice={otherPrice.price.formatted}
                                isSecondary
                                discount={(
                                    <RenderDiscount
                                        discountOff={otherPrice.discount.discountOff}
                                        original={otherPrice.price.original}
                                        isUnitPrice
                                    />
                                )}
                            />
                        </li>
                    ))}
                    {Boolean(setupFees && setupFees.length) && setupFees.map(setupFee => (
                        <li>
                            <RenderPrice
                                formattedPrice={setupFee.formattedFullPriceElements}
                                key={generateUniqueID([...setupFee.formattedFullPriceElements, uuid])}
                                isSecondary
                                textSeparator={' '}
                                discount={(
                                    <RenderDiscount
                                        discountOff={setupFee.price.formatted.discountOff}
                                        original={setupFee.price.formatted.originalFullPriceElements}
                                        isUnitPrice
                                    />
                                )}
                            />
                        </li>
                    ))}
                    {Boolean(contractFees && contractFees.length) && contractFees.map(contractFee => (
                        <li>
                            <RenderPrice
                                formattedPrice={contractFee.formattedFullPriceElements}
                                key={generateUniqueID([...contractFee.formattedFullPriceElements, uuid])}
                                isSecondary
                                textSeparator={' '}
                                discount={(
                                    <RenderDiscount
                                        discountOff={contractFee.price.formatted.discountOff}
                                        original={contractFee.price.formatted.originalFullPriceElements}
                                        isUnitPrice
                                    />
                                )}
                            />
                        </li>
                    ))}
                </ul>
            )}
        </>
    );
};

export const RenderPrice = ({
    formattedPrice: [price, priceUnit, frequency],
    isSecondary,
    textSeparator,
    unit,
    discount,
    planType
}) => {
    const priceLimit = getPriceLimitLabel(unit);
    const modifiers = [
        isSecondary ? 'secondary' : 'primary',
        isSecondary && 'with-icon',
        planType
    ];

    return (
        <div {...n('pricing', modifiers).withTestId().withE2EId().props}>
            {isSecondary && (
                <Icon type="plus" {...n('pricingPlusIcon').props} aria-hidden="true" />
            )}
            <Pricing
                price={price}
                frequency={frequency ? stripSlash(frequency) : ''}
                unit={priceUnit ? stripSlash(priceUnit) : ''}
                isEmphasis={!isSecondary}
                textSeparator={textSeparator}
                priceExtraClass={n('pricingValue').props.className}
            />
            {priceLimit && (
                <div {...n('pricingLimit').withTestId().props}>{priceLimit}</div>
            )}
            {discount && (
                <div {...n('pricingDiscount').props}>{discount}</div>
            )}
        </div>
    );
};

export const RenderDiscount = ({
    original,
    discountOff,
    isUnitPrice
}) => {
    if (!discountOff) {
        return null;
    }

    const [price, unit, frequency] = original;

    return (
        <div {...n('discountSection', isUnitPrice ? 'unit' : null).withTestId().props}>
            <div {...n('discountLabel').withTestId().props}>
                <Pricing price={price} unit={isUnitPrice ? unit : ''} frequency={isUnitPrice ? frequency : ''} textSeparator="" />
            </div>
            {discountOff && (<div {...n('discountOff').withTestId().props}>{parseDiscountOff(discountOff)}</div>)}
        </div>
    );
};

const RenderButton = ({ name, configuratorMode, isSelected, i18n, id, moveFocusOnKeyboardSelection,
    callToAction, onSelect, tabIndex, isAddedToCart, nonStackableProduct, hasAddons }) => {
    let ariaLabel = '';
    const label = getActionLabel(
        configuratorMode,
        isSelected,
        i18n,
        callToAction,
        isAddedToCart,
        nonStackableProduct,
        hasAddons
    );
    const buttonExtraClass = callToAction.actionType && `btn-edition-${callToAction.actionType.toLowerCase()}`;

    if (configuratorMode) {
        ariaLabel = `${isSelected ? i18n.selected : i18n.select}: ${name}`;
    }

    if (isAddedToCart && canReplaceEdition(callToAction, nonStackableProduct, hasAddons)) {
        return (
            <div {...n('buttonWrapper').withTestId('actions-container').withE2EId('actions-container').props}>
                <EditionButtonIcon
                    icon="check"
                    theme="emphasisAlt-outline"
                    type="button"
                    data-testid={`button:added-to-cart:edition-${id}`}
                    ctaType={CTA_ADD_TO_CART}
                    onClick={onSelect}
                    aria-label={ariaLabel}
                    tabIndex={tabIndex}
                    notClickable
                    iconClass="addedToCart"
                >
                    {label}
                </EditionButtonIcon>
            </div>
        );
    }

    if (isSelected) {
        return (
            <div {...n('buttonWrapper').withTestId('actions-container').withE2EId('actions-container').props}>
                <EditionButtonIcon
                    icon="check"
                    theme="primary-outline"
                    type="button"
                    data-testid={`button:select:edition-${id}`}
                    ctaType={callToAction.actionType}
                    onClick={onSelect}
                    aria-label={ariaLabel}
                    tabIndex={tabIndex}
                    notClickable
                    iconClass="selected"
                >
                    {label}
                </EditionButtonIcon>
            </div>
        );
    }

    return label ? (
        <div {...n('buttonWrapper').withTestId('actions-container').withE2EId('actions-container').props}>
            <Button
                data-testid={`button:select:edition-${id}`}
                type={getButtonTypeForCta(callToAction)}
                onClick={onSelect}
                className={buttonExtraClass}
                ctaType={callToAction.actionType}
                wide
                aria-label={ariaLabel}
                tabIndex={tabIndex}
                onKeyDown={moveFocusOnKeyboardSelection}
            >
                {label}
            </Button>
        </div>
    ) : '';
};

export const RenderInclusions = ({ items, i18n }) => {
    if (!items || !items.length) {
        return null;
    }

    return (
        <div {...n('inclusions').props}>
            <span {...n('sectionTitle').withTestId('inclusionsTitle').withE2EId('inclusionsTitle').props}>{i18n.inclusions}</span>
            {items.map(({ content }) => (
                <div key={`includes-${content}`} {...n().withTestId('inclusionsItem').withE2EId('inclusionsItem').props}>
                    {content}
                </div>
            ))}
        </div>
    );
};

export const RenderAudience = ({ audience, i18n }) => {
    if (!audience || !audience.length) {
        return null;
    }

    return (
        <div {...n('audience').withTestId().props}>
            <span {...n('sectionTitle').withTestId('audienceTitle').withE2EId('audienceTitle').props}>{i18n.audience}</span>
            {audience.map(({ content }) => (
                <div key={`audience-${content}`} {...n('section').withTestId('audienceItem').withE2EId('audienceItem').props}>
                    {content}
                </div>
            ))}
        </div>
    );
};

const RenderBullet = ({ bullet }) => {
    const { content, tooltip } = bullet;
    return (
        <li {...n('bullet').withTestId().withE2EId('bullet').props}>
            <Bullet content={content} tooltip={tooltip} iconType="check" />
        </li>
    );
};

const RenderBullets = ({ bullets }) => {
    if (!bullets || !bullets.length) {
        return null;
    }
    return (
        <ul {...n('bullets').props}>
            {bullets.map((bullet, index) => (
                <RenderBullet bullet={bullet} key={generateUniqueID([bullet.content, index])} />
            ))}
        </ul>
    );
};

export const ProductEditionCardComponent = forwardRef((
    {
        data: {
            id,
            name,
            code,
            description,
            primary,
            plans,
            audience,
            items,
            bullets,
            callToAction,
            freeTrialDuration,
            freeTrialType
        },
        configuratorMode,
        isDetailCollapsed,
        isSelected,
        onSelect,
        carouselEnabled,
        onExpand,
        titleHeight,
        height,
        i18n,
        isIncludedHidden,
        showCode,
        isAddedToCart,
        nonStackableProduct,
        hasAddons,
        moveFocusOnKeyboardSelection
    },
    forwardedRefs
) => {
    const containerRef = useRef();
    const [isCarouselA11yVisible] = useCarouselA11yVisible(containerRef);
    const isA11yVisible = isCarouselA11yVisible || !carouselEnabled;
    const buttonsTabIndex = isA11yVisible ? 0 : -1;
    const [isCollapse, setCollapseState] = useState(true);
    const pricingAction = parsePricingAction(callToAction);

    const {
        titleRef,
        mainRef
    } = forwardedRefs || {};

    if (isDetailCollapsed !== null && isDetailCollapsed !== isCollapse) {
        setCollapseState(isDetailCollapsed);
    }

    const toggleDetails = () => {
        if (onExpand) {
            onExpand();
        } else {
            setCollapseState(!isCollapse);
        }
    };

    const onKeyboardSelection = e => {
        if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            toggleDetails();
        }
    };

    const containerModifiers = [
        primary && 'with-ribbon'
    ];
    const containerVariables = {
        infoHeight: (height && `${height}px`) || 'auto',
        titleHeight: (titleHeight && `${titleHeight}px`) || 'auto'
    };

    const mainModifiers = [
        configuratorMode && 'configurator-mode',
        primary && 'with-ribbon',
        configuratorMode && 'with-buttons',
        !isCollapse && 'with-details'
    ];

    // Remove empty costs from the plans array
    const productPlans = plans && plans.length ? plans.reduce((previous, current) => {
        if (current.costs && Object.keys(current.costs).length !== 0) {
            previous.push(current);
        }

        return previous;
    }, []) : null;

    const detailsSectionId = generateUniqueID([id, name]);

    return (
        <div
            {...n('container', containerModifiers).withVariables(containerVariables).withTestId().withE2EId().props}
            ref={containerRef}
        >
            <article {...n('main', mainModifiers).props} ref={mainRef}>
                {primary && <div {...n('ribbon').withTestId().withE2EId().props}>{i18n.mostPopular}</div>}
                <div {...n('header').props} ref={titleRef}>
                    <h3 {...n('title').withTestId().withE2EId().props}>{name}</h3>
                    {showCode && code && <p {...n('code').withTestId().withE2EId().props}>{code}</p>}
                    {description && <p {...n('description').withTestId().withE2EId().props}>{description}</p>}
                    {freeTrialDuration && freeTrialType && (
                        <div {...n('trialContainer').props}>
                            <Badge {...n('trialBadge').props} label={`${freeTrialDuration} ${freeTrialType} ${i18n.freeTrial}`} type="success" />
                        </div>
                    )}
                </div>
                {productPlans && productPlans.length ? (
                    <ul {...n('plans').props} aria-label={i18n.availablePricing}>
                        {plans.map(plan => <RenderPlan plan={plan} key={plan.uuid} />)}
                    </ul>
                ) : ''}
                <div {...n('actionsWrapper').props}>
                    <RenderButton
                        configuratorMode={configuratorMode}
                        isSelected={isSelected}
                        onSelect={onSelect}
                        i18n={i18n}
                        id={id}
                        callToAction={pricingAction}
                        tabIndex={buttonsTabIndex}
                        name={name}
                        isAddedToCart={isAddedToCart}
                        nonStackableProduct={nonStackableProduct}
                        hasAddons={hasAddons}
                        moveFocusOnKeyboardSelection={moveFocusOnKeyboardSelection}
                    />
                    {configuratorMode && (
                        <div {...n('actionLink').withE2EId().props}>
                            <Button
                                buttonType="link"
                                type="primary"
                                onClick={toggleDetails}
                                onKeyDown={onKeyboardSelection}
                                {...n('actionLinkLabel').withTestId().withClass('btn-toggle-details').props}
                                aria-expanded={!isCollapse ? 'true' : 'false'}
                                aria-controls={detailsSectionId}
                                aria-label={`${name}: ${isCollapse ? i18n.viewDetails : i18n.hideDetails}`}
                                tabIndex={buttonsTabIndex}
                            >
                                {isCollapse ? i18n.viewDetails : i18n.hideDetails}
                            </Button>
                        </div>
                    )}
                </div>
            </article>
            {!isCollapse && (
                <div {...n('details').withTestId().withE2EId().props} id={detailsSectionId}>
                    {items && !isIncludedHidden && <RenderInclusions items={items} i18n={i18n} />}
                    {audience && <RenderAudience audience={audience} i18n={i18n} />}
                    {bullets && <RenderBullets bullets={bullets} />}
                </div>
            )}
        </div>
    );
});

const i18nDefault = {
    audience: 'Ideal For',
    inclusions: 'Included',
    mostPopular: 'Most Popular',
    select: 'Select',
    selected: 'Selected',
    hideDetails: 'Hide Details',
    viewDetails: 'View Details',
    freeTrial: 'free trial',
    availablePricing: 'Available Pricing:',
    cart: {
        addedToCart: 'Added to Cart'
    }
};

const planDefault = {
    costs: {},
    setupFees: [],
    constractFees: [],
    formattedContract: '',
    uuid: ''
};

const bulletSchema = PropTypes.shape({
    content: PropTypes.string,
    tooltip: PropTypes.string
});

const bulletsSchema = PropTypes.arrayOf(bulletSchema);

const i18nSchema = PropTypes.shape({
    audience: PropTypes.string,
    inclusions: PropTypes.string,
    mostPopular: PropTypes.string,
    select: PropTypes.string,
    selected: PropTypes.string,
    hideDetails: PropTypes.string,
    viewDetails: PropTypes.string,
    freeTrial: PropTypes.string,
    availablePricing: PropTypes.string,
    cart: PropTypes.object
});

const callToActionSchema = PropTypes.shape({
    label: PropTypes.string,
    tooltip: PropTypes.string,
    isPrimary: PropTypes.bool,
    enabled: PropTypes.bool,
    url: PropTypes.string,
    actionType: PropTypes.string,
    popup: PropTypes.shape(),
    isSecondary: PropTypes.bool
});

const priceTypeSchema = PropTypes.shape({
    formattedFullPriceElements: PropTypes.arrayOf(PropTypes.string),
    originalFullPriceElements: PropTypes.arrayOf(PropTypes.string),
    unit: PropTypes.shape({
        limitLabel: PropTypes.string
    })
});

const planSchema = PropTypes.shape({
    costs: PropTypes.shape({
        flatPrice: priceTypeSchema,
        unitPrice: PropTypes.arrayOf(priceTypeSchema)
    }),
    setupFees: PropTypes.arrayOf(
        PropTypes.shape({
            formattedFullPriceElements: PropTypes.arrayOf(PropTypes.string)
        })
    ),
    contractFees: PropTypes.arrayOf(
        PropTypes.shape({
            formattedFullPriceElements: PropTypes.arrayOf(PropTypes.string)
        })
    ),
    formattedContract: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
    uuid: PropTypes.string
});

const plansSchema = PropTypes.arrayOf(planSchema);

const itemsSchema = PropTypes.arrayOf(
    PropTypes.shape({
        content: PropTypes.string
    })
);

const dataAudienceSchema = PropTypes.arrayOf(
    PropTypes.shape({
        content: PropTypes.string
    })
);

RenderBullets.propTypes = {
    bullets: bulletsSchema
};

RenderBullets.defaultProps = {
    bullets: []
};

RenderBullet.propTypes = {
    bullet: bulletSchema
};

RenderBullet.defaultProps = {
    bullet: {}
};

RenderAudience.propTypes = {
    audience: dataAudienceSchema,
    i18n: i18nSchema
};

RenderAudience.defaultProps = {
    audience: [],
    i18n: i18nDefault
};

RenderInclusions.propTypes = {
    items: itemsSchema,
    i18n: i18nSchema
};

RenderInclusions.defaultProps = {
    items: [],
    i18n: i18nDefault
};

RenderButton.propTypes = {
    configuratorMode: PropTypes.bool,
    isSelected: PropTypes.bool,
    onSelect: PropTypes.func,
    moveFocusOnKeyboardSelection: PropTypes.func,
    i18n: i18nSchema,
    id: PropTypes.number,
    callToAction: callToActionSchema,
    tabIndex: PropTypes.number,
    name: PropTypes.string,
    isAddedToCart: PropTypes.bool,
    nonStackableProduct: PropTypes.bool,
    hasAddons: PropTypes.bool
};

RenderButton.defaultProps = {
    configuratorMode: false,
    isSelected: false,
    onSelect: () => {},
    moveFocusOnKeyboardSelection: () => {},
    i18n: i18nDefault,
    id: 0,
    callToAction: {},
    tabIndex: 0,
    name: '',
    isAddedToCart: false,
    nonStackableProduct: false,
    hasAddons: false
};

RenderDiscount.propTypes = {
    discountOff: PropTypes.string,
    original: PropTypes.arrayOf(PropTypes.string),
    isUnitPrice: PropTypes.bool
};

RenderDiscount.defaultProps = {
    discountOff: '',
    original: null,
    isUnitPrice: false
};

RenderPrice.propTypes = {
    formattedPrice: PropTypes.arrayOf(PropTypes.string),
    isSecondary: PropTypes.bool,
    textSeparator: PropTypes.string,
    unit: PropTypes.shape({
        min: PropTypes.number,
        max: PropTypes.number,
        limitLabel: PropTypes.string
    }),
    discount: PropTypes.element,
    planType: PropTypes.oneOf(['costs', 'setupFees', 'contractFees'])
};

RenderPrice.defaultProps = {
    formattedPrice: [],
    isSecondary: false,
    textSeparator: '/',
    unit: null,
    discount: null,
    planType: 'costs'
};

RenderPlan.propTypes = {
    plan: planSchema
};

RenderPlan.defaultProps = {
    plan: PropTypes.shape(planDefault)
};

RenderCosts.propTypes = {
    plan: planSchema
};

RenderCosts.defaultProps = {
    plan: PropTypes.shape(planDefault)
};

export const defaultEditionsProps = PropTypes.shape({
    id: PropTypes.number,
    name: PropTypes.string,
    code: PropTypes.string,
    description: PropTypes.string,
    primary: PropTypes.bool,
    plans: plansSchema,
    audience: dataAudienceSchema,
    items: itemsSchema,
    bullets: PropTypes.arrayOf(
        PropTypes.shape({
            content: PropTypes.string,
            tooltip: PropTypes.string
        })
    ),
    callToAction: callToActionSchema,
    freeTrialDuration: PropTypes.number,
    freeTrialType: PropTypes.string
});

ProductEditionCardComponent.schema = () => ({
    name: 'Product Editions',
    form: {}
});

ProductEditionCardComponent.propTypes = {
    data: defaultEditionsProps,
    i18n: i18nSchema,
    titleHeight: PropTypes.number,
    height: PropTypes.number,
    isSelected: PropTypes.bool,
    carouselEnabled: PropTypes.bool,
    configuratorMode: PropTypes.bool,
    isDetailCollapsed: PropTypes.bool,
    onSelect: PropTypes.func,
    onExpand: PropTypes.func,
    isIncludedHidden: PropTypes.bool,
    showCode: PropTypes.bool,
    isAddedToCart: PropTypes.bool,
    nonStackableProduct: PropTypes.bool,
    hasAddons: PropTypes.bool,
    moveFocusOnKeyboardSelection: PropTypes.func
};

ProductEditionCardComponent.defaultProps = {
    data: {},
    i18n: i18nDefault,
    titleHeight: null,
    height: null,
    isSelected: false,
    carouselEnabled: false,
    configuratorMode: false,
    isDetailCollapsed: null,
    onSelect: () => {},
    onExpand: null,
    isIncludedHidden: false,
    showCode: false,
    isAddedToCart: false,
    nonStackableProduct: false,
    hasAddons: false,
    moveFocusOnKeyboardSelection: () => {}
};

export default ProductEditionCardComponent;
