import PropTypes, { arrayOf } from 'prop-types';

const cartItemDetailsShape = {
    branding: PropTypes.shape({
        desc: PropTypes.string,
        href: PropTypes.string,
        iconUrl: PropTypes.string,
        name: PropTypes.string,
        storefrontUrl: PropTypes.string,
        vendor: PropTypes.string
    }),
    customAttributes: PropTypes.arrayOf(PropTypes.string),
    customIntegration: PropTypes.string,
    editions: PropTypes.arrayOf(PropTypes.shape({
        autoUpgradeToPaid: PropTypes.bool,
        bundleOnly: PropTypes.bool,
        editionCode: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
        freeTrialRequiresBillingInfo: PropTypes.string,
        freeTrialTerms: PropTypes.shape({
            freeTrialDuration: PropTypes.number,
            freeTrialDurationPeriod: PropTypes.string,
            freeTrialGracePeriod: PropTypes.number
        }),
        id: PropTypes.string,
        name: PropTypes.string,
        pricingPlans: PropTypes.arrayOf(PropTypes.shape({
            additionalFees: PropTypes.shape({
                terminationFee: PropTypes.string
            }),
            contractConfiguration: PropTypes.string,
            currency: PropTypes.string,
            id: PropTypes.string,
            pricingPeriod: PropTypes.string,
            pricingSources: PropTypes.arrayOf(PropTypes.shape({
                allowsMeteredUsage: PropTypes.string,
                costType: PropTypes.string,
                costTypeCategory: PropTypes.string,
                displaysPricePerIncrement: PropTypes.bool,
                increment: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
                sources: PropTypes.arrayOf(PropTypes.shape({
                    priceRanges: PropTypes.arrayOf(PropTypes.shape({
                        min: PropTypes.number,
                        max: PropTypes.number,
                        price: PropTypes.number
                    })),
                    priceType: PropTypes.string,
                    pricingStrategy: PropTypes.string,
                    salePrice: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
                })),
                unit: PropTypes.string,
                unitAllowsDecimals: PropTypes.string
            }))
        })),
        revenueModel: PropTypes.string
    })),
    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    stacked: false,
    type: PropTypes.oneOf(['PRODUCT']),
    uuid: PropTypes.string
};

const cartItemDefaultShape = {
    billingConfiguration: PropTypes.string,
    customAttributes: PropTypes.string,
    customPrices: PropTypes.arrayOf(PropTypes.shape()),
    discountCode: PropTypes.string,
    discountId: PropTypes.string,
    id: PropTypes.string,
    itemDetails: PropTypes.shape(cartItemDetailsShape),
    pricingPlanId: PropTypes.string,
    selectedEditionId: PropTypes.string,
    selectedPricingPlanId: PropTypes.string,
    serviceConfiguration: PropTypes.string,
    subscriptionId: PropTypes.string,
    units: PropTypes.arrayOf(PropTypes.string),
    validated: PropTypes.bool
};

const cartChildItemDetailsShape = {
    ...cartItemDefaultShape
};

export const cartItemShape = {
    ...cartItemDefaultShape,
    childItems: arrayOf(PropTypes.shape(cartChildItemDetailsShape)),
    contractInfo: PropTypes.shape({
        contractConfiguration: PropTypes.string,
        additionalFees: PropTypes.shape({
            terminationFee: PropTypes.string
        })
    }),
    costs: PropTypes.arrayOf(PropTypes.shape({
        costId: PropTypes.string,
        costTypeCategory: PropTypes.string,
        costType: PropTypes.string,
        pricingStrategy: PropTypes.string,
        unit: PropTypes.string,
        definition: PropTypes.shape({
            price: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
            priceRanges: PropTypes.arrayOf(PropTypes.shape({
                min: PropTypes.number,
                max: PropTypes.number,
                price: PropTypes.number
            }))
        }),
        calculations: PropTypes.arrayOf(PropTypes.shape({
            quantity: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
            salePrice: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
            totalPrice: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
            salePriceTaxIncluded: PropTypes.string,
            totalPriceTaxIncluded: PropTypes.string
        })),
        costDescription: PropTypes.string
    })),
    payment_schedule: PropTypes.shape({
        billingCycle: PropTypes.shape({
            period: PropTypes.string,
            dayOfMonth: PropTypes.number
        }),
        servicePeriod: PropTypes.shape({
            start: PropTypes.string,
            end: PropTypes.string
        }),
        billingPeriod: PropTypes.shape({
            start: PropTypes.string,
            end: PropTypes.string
        }),
        freeTrialPeriod: PropTypes.shape({
            start: PropTypes.string,
            end: PropTypes.string
        }),
        events: PropTypes.arrayOf(PropTypes.shape({
            eventType: PropTypes.string,
            edated: PropTypes.string
        }))
    })
};

const i18nCartShape = {
    cart: PropTypes.string,
    emptyCart: PropTypes.shape({
        title: PropTypes.string,
        'sign.in': PropTypes.string
    }),
    title: PropTypes.string,
    viewCart: PropTypes.string
};

export const cartShape = {
    associations: PropTypes.arrayOf(PropTypes.shape()),
    buyerType: PropTypes.oneOf(['CUSTOMER']),
    currency: PropTypes.string,
    i18n: PropTypes.shape(i18nCartShape),
    id: PropTypes.string,
    items: PropTypes.arrayOf(PropTypes.shape(cartItemShape)),
    itemsCount: PropTypes.number,
    pricingTotal: PropTypes.shape({
        amountDueAfterTax: PropTypes.string,
        amountDueBeforeTax: PropTypes.string,
        recurringTotals: PropTypes.arrayOf(PropTypes.shape({
            billingCycle: PropTypes.shape({
                dayOfMonth: PropTypes.number,
                period: PropTypes.string
            }),
            totalSalePrice: PropTypes.string,
            totalSalePriceTaxIncluded: PropTypes.bool
        })),
        taxSummary: PropTypes.arrayOf(PropTypes.shape({
            description: PropTypes.string,
            taxAmount: PropTypes.string
        })),
        totalTaxAmount: PropTypes.string
    }),
    status: PropTypes.oneOf(['ACTIVE'])
};
