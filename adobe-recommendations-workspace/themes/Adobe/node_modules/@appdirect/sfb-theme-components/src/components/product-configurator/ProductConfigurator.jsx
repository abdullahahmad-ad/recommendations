import React, { useState, useEffect, useCallback, useMemo } from 'react';
import useResizeObserver from 'use-resize-observer';
import PropTypes from 'prop-types';
import withListener from '../withListener';
import { createNamespace } from '../../tools/namingTools';
import { bSmall, bMedium, bLarge } from '../../constants/breakpoints';
import { useContainerWidth } from '../../tools/widths/useContainerWidth';
import { useIsScrolledPassedWindowHeight } from '../../tools/interactivity/scroll';
import { ANCHOR_PRODUCT_CONFIGURATOR } from '../../constants/anchors';
import ProductAddonList from '../../atoms/product-addon/list/ProductAddonList';
import { addonShape } from '../../constants/components/prop-types/addon';
import ProductEditionList, { defaultEditionsProps } from '../../atoms/product-edition/list/ProductEditionList';
import { SelectionPreviewComponent } from '../../atoms/selection-preview/SelectionPreview';
import { configuratorPropTypes } from '../../constants/prop-types/application/configurator';
import { getUrlParams } from '../../tools/urlTools';
import GridContainer from '../../atoms/grid-container/GridContainer';
import Button from '../../atoms/button/Button';
import ButtonPageScroll from '../../atoms/button-page-scroll/ButtonPageScroll';
import Icon from '../../atoms/icon/Icon';
import { DEFAULT_IMG } from '../../constants/images';
import { callToActionListShape } from '../../constants/prop-types/application/call-to-actions';
// IMPORTANT: (s)css should be imported after other atoms/components
import './styles/ProductConfigurator.scss';

const n = createNamespace('ProductConfigurator');

const getUrlParamValue = key => {
    const urlParams = getUrlParams();

    if (key && urlParams[key] && urlParams[key].length) {
        return urlParams[key][0] !== 'false';
    }

    return true;
};

const getFilteredAddonsForEdition = (addons = [], selectedEditionId) => addons
    .filter(({ parentEditionId, parentEditionIds }) => !parentEditionId
        || parentEditionId === selectedEditionId
        || parentEditionIds?.includes(selectedEditionId));

const addSelectedAddons = (newAddon, addons) => [].concat(addons, [newAddon]);

const removeSelectedAddon = (removedAddon, addons) => addons.filter(addon => (addon.id !== removedAddon.id));

export const getDefaultSelectedEdition = (selectedEdition, allEditions) => (
    selectedEdition || allEditions.find(edition => edition.primary) || allEditions[0]
);

export const ProductConfiguratorComponent = ({ data }) => {
    const {
        editions = {},
        addonProducts = {},
        configurator = { selectedEdition: null, backAction: {}, i18n: {} },
        callToActions = {},
        summary = {},
        user,
        i18nCart
    } = data;

    const hasAddons = !!addonProducts?.items?.length;
    const { isNonStackableWithAddonsAppInCart } = configurator;
    const [isAddedToCart, setAddedToCart] = useState(isNonStackableWithAddonsAppInCart);
    const [containerRef, containerWidth] = useContainerWidth();
    const isMobile = Boolean(containerWidth && containerWidth < bSmall);
    const isMobileXL = Boolean(containerWidth && containerWidth < bMedium);
    const isTablet = Boolean(containerWidth && containerWidth < bLarge);

    const i18n = { ...ProductConfiguratorComponent.defaultProps.data.i18n, ...configurator.i18n };
    const componentVariables = {};
    const containerModifiers = [isMobileXL && 'with-preview-sticky-bottom'];
    const { logoSrc, logoAlt } = summary;
    const [isEditionsVisible, setEditionsVisibleState] = useState(getUrlParamValue('showEditions'));
    const [selectedEdition, setSelectedEdition] = useState(
        getDefaultSelectedEdition(configurator.selectedEdition, editions.items)
    );
    const [selectedAddons = [], setSelectedAddons] = useState(configurator.selectedAddons);
    const [isPreviewCondensed, setPreviewCondensedState] = useState(false);
    const [isPreviewFullscreen, setPreviewFullscreenState] = useState(false);
    const [filteredAddons, setFilteredAddons] = useState(
        getFilteredAddonsForEdition(addonProducts.items, selectedEdition.id)
    );

    const [uncondensedHeight, setUncondensedHeight] = useState(0);
    const [previewHeight, setPreviewHeight] = useState(0);
    const [focusSelectionPreview, setFocusSelectionPreview] = useState('');

    const { ref: selectionPreviewRef } = useResizeObserver({
        onResize: ({ height }) => {
            if (!isPreviewCondensed && height > uncondensedHeight) {
                setUncondensedHeight(height);
            }
            if (isMobileXL) {
                setUncondensedHeight(0);
                setPreviewHeight(height);
            }
        }
    });

    const getCondensedState = useCallback(() => () => {
        if (isMobile) {
            return true;
        }
        return !isMobileXL ? window.scrollY > 0 : false;
    }, [isMobileXL, isMobile]);

    const onScroll = useCallback(() => {
        const isCondensed = getCondensedState();
        setPreviewCondensedState(isCondensed);
    }, [getCondensedState]);

    const showBackTopButton = useIsScrolledPassedWindowHeight();

    useEffect(() => {
        onScroll();
        window.addEventListener('scroll', onScroll);

        return () => {
            window.removeEventListener('scroll', onScroll);
        };
    }, [onScroll]);

    const changeEdition = newEdition => {
        setSelectedEdition(newEdition);
        setSelectedAddons([]);
        setUncondensedHeight(0);
        setFilteredAddons(getFilteredAddonsForEdition(addonProducts.items, newEdition.id));
    };

    const changeAddons = newAddons => {
        setUncondensedHeight(0);
        setSelectedAddons(newAddons);
        setAddedToCart(false);
    };

    const showEditions = () => {
        setEditionsVisibleState(true);
    };

    const renderBackButton = useMemo(() => (
        <div {...n('backAction').props}>
            <a {...n('backActionLink').withTestId().props} href={configurator.backAction.url}>
                <Icon type="caretLeft" {...n('backActionIcon').props} />
                <span {...n('backActionLabel').withTestId().withE2EId().props}>{configurator.backAction.label}</span>
            </a>
        </div>
    ), [configurator.backAction]);

    const renderBackTopButton = (
        <div {...n('backTopWrapper').props}>
            <ButtonPageScroll
                {...n('backTopButton').props}
                text={i18n.backTop}
                hiddenButton={!showBackTopButton}
                mobileOnly
            />
        </div>
    );

    const renderSelectionPreview = () => {
        const modifiers = [isMobileXL ? 'sticky-bottom' : 'sticky-top'];

        if (isPreviewCondensed) {
            modifiers.push('is-condensed');
            modifiers.push('with-boxshadow');
        }

        if (isPreviewFullscreen) {
            modifiers.push('fullscreen');
        }

        const style = uncondensedHeight ? { stickyheight: `${uncondensedHeight}px` } : null;

        return (
            <div {...n('preview-sticky', modifiers).withVariables(style).props}>
                <div {...n('preview', modifiers).props} ref={selectionPreviewRef} aria-live="polite" role="region">
                    {!isMobileXL && renderBackButton}
                    <SelectionPreviewComponent
                        data={{
                            configurator,
                            selectedEdition,
                            selectedAddons,
                            callToActions,
                            productImgSrc: logoSrc,
                            productImageAlt: logoAlt,
                            isAddedToCart,
                            user,
                            i18nCart
                        }}
                        isCondensed={isPreviewCondensed}
                        isFullscreen={isTablet && isPreviewFullscreen}
                        onCollapseAddons={isAddonsCollapsed => {
                            if (isMobileXL) {
                                setPreviewFullscreenState(isAddonsCollapsed);
                            }
                        }}
                    />
                </div>
            </div>
        );
    };

    if (previewHeight) {
        componentVariables.previewHeight = `${previewHeight}px`;
    }

    useEffect(() => {
        const selectionPreviewFocus = document.querySelectorAll('#selectionPreview button')?.[0];
        setFocusSelectionPreview(selectionPreviewFocus);
    }, []);

    return (
        <div {...n('container', containerModifiers).withVariables(componentVariables).props} id={ANCHOR_PRODUCT_CONFIGURATOR} ref={containerRef}>
            {!isMobileXL && renderSelectionPreview()}
            {isMobileXL && renderBackButton}
            <div {...n('configurator').props}>
                {isEditionsVisible && !isNonStackableWithAddonsAppInCart ? (
                    <div {...n('editions').props}>
                        <ProductEditionList
                            data={{
                                editions: editions.items,
                                i18n: {
                                    ...i18n,
                                    ...editions.i18n,
                                    viewAddons: i18n.viewAddons
                                }
                            }}
                            hasAddons={hasAddons}
                            configuratorMode
                            carouselEnabled={isMobileXL}
                            carouselSlidesToShow={isMobile ? 1 : 2}
                            selectedEditionId={selectedEdition.id}
                            onEditionSelect={(newEdition = {}) => changeEdition(newEdition)}
                            focusWhenTabSelected={focusSelectionPreview}
                        />
                    </div>
                ) : null}
                {!isEditionsVisible && !isNonStackableWithAddonsAppInCart ? (
                    <GridContainer>
                        <div {...n('btnShowEditions').props}>
                            <Button
                                buttonType="link"
                                data-testid="button:showEditions"
                                type="primary"
                                onClick={() => showEditions()}
                            >
                                {i18n.changeEdition}
                                <Icon type={!isEditionsVisible ? 'caretUp' : 'caretDown'} {...n('btnShowEditionsIcon').props} />
                            </Button>
                        </div>
                    </GridContainer>
                ) : null}
                {hasAddons && (
                    <div {...n('addons').props}>
                        <ProductAddonList
                            data={{
                                addonProducts: {
                                    i18n: {
                                        ...addonProducts.i18n,
                                        addons: i18n.availableAddons,
                                        viewEditions: i18n.viewEditions
                                    },
                                    items: filteredAddons
                                }
                            }}
                            selectedAddons={selectedAddons}
                            selectable
                            onAddonSelect={(currentAddon = {}) => {
                                changeAddons(addSelectedAddons(currentAddon, selectedAddons));
                            }}
                            onViewEditions={() => showEditions()}
                            onAddonRemove={(currentAddon = {}) => {
                                changeAddons(removeSelectedAddon(currentAddon, selectedAddons));
                            }}
                        />
                    </div>
                )}
            </div>
            {isMobileXL && renderBackTopButton}
            {isMobileXL && renderSelectionPreview()}
        </div>
    );
};

ProductConfiguratorComponent.schema = () => ({
    name: 'ProductConfigurator',
    title: 'uieditor.sfbComponent.productConfigurator.title',
    form: {},
    marketplaceData: {
        editions: 'application.editions',
        addonProducts: 'application.addonProducts',
        configurator: 'application.configurator',
        callToActions: 'application.callToActions',
        summary: 'application.summary',
        user: 'config.user',
        i18nCart: 'i18n.cart'
    }
});

ProductConfiguratorComponent.propTypes = {
    data: PropTypes.shape({
        addonProducts: addonShape,
        editions: defaultEditionsProps,
        configurator: configuratorPropTypes,
        callToActions: callToActionListShape,
        i18n: PropTypes.shape({
            selectEditionTitle: PropTypes.string,
            availableAddons: PropTypes.string,
            changeEdition: PropTypes.string,
            viewEditions: PropTypes.string,
            viewAddons: PropTypes.string,
            backTop: PropTypes.string
        }),
        summary: PropTypes.shape({
            details: PropTypes.string,
            logoSrc: PropTypes.string,
            logoSrcset: PropTypes.shape({
                default: PropTypes.string,
                '1x': PropTypes.string,
                '2x': PropTypes.string
            }),
            logoAlt: PropTypes.string,
            overview: PropTypes.string,
            title: PropTypes.string
        }),
        user: PropTypes.object,
        i18nCart: PropTypes.object
    })
};

ProductConfiguratorComponent.defaultProps = {
    data: {
        editions: {
            items: []
        },
        addonProducts: {
            items: []
        },
        callToActions: {
            items: []
        },
        configurator: {},
        i18n: {
            selectEditionTitle: 'Select an edition for this product',
            availableAddons: 'Available add-ons',
            changeEdition: 'Change Edition',
            viewEditions: 'View Editions',
            viewAddons: 'View Add-ons',
            backTop: 'Back to top'
        },
        summary: {
            details: '',
            logoSrc: DEFAULT_IMG,
            logoSrcset: null,
            logoAlt: '',
            overview: '',
            title: ''
        },
        user: {
            isLoggedIn: false
        },
        i18nCart: {
            addedToCart: 'Added to Cart'
        }
    }
};

export default withListener(ProductConfiguratorComponent);
